
auglag.cpp,498
static const NLConOpt *problem;problem35,1441
static vector<double> lambda;lambda36,1473
static double mu;mu37,1503
void augmented_lagrangian_method (const NLConOpt &problem, OptOptions opt,augmented_lagrangian_method44,1727
inline double clamp_violation (double x, int sign) {clamp_violation81,2994
static void auglag_value_and_grad (const real_1d_array &x, double &value,auglag_value_and_grad84,3111
static void multiplier_update (const real_1d_array &x) {multiplier_update115,4275

blockvectors.hpp,436
#define BLOCKVECTORS_HPPBLOCKVECTORS_HPP28,1323
Vec<m*n,T> mat_to_vec (const Mat<m,n,T> &A) {mat_to_vec33,1409
Mat<m,n,T> vec_to_mat (const Vec<m*n,T> &a) {vec_to_mat42,1625
template <int bn, int m, int n, typename T> Mat<m*bn,n*bn,T> blockdiag (const Mat<m,n,T> &A) {blockdiag50,1805
template <int m, int n> Mat<m*n,m*n,double> transpose () {transpose59,2096
template <> inline Mat<3,4> symmetrize<2> () {symmetrize69,2356

breaking.cpp,728
const int SUPPORT_RINGS = 2;SUPPORT_RINGS46,1687
double edge_plane_intersect(const Vec3& e0, const Vec3& e1, const Vec3& u0, const Vec3& n) {edge_plane_intersect48,1717
Edge* split_edge_with_plane(Face* face, Node* node, Vec3& n) {split_edge_with_plane54,1935
void displace_sector(Node* node, double disp) {displace_sector94,3406
void split_sector(Node* node, Edge* start, Edge* end, MeshSubset& subset) {split_sector110,3869
void fix_nonmanifold(Node* node, MeshSubset& subset) {fix_nonmanifold173,5766
bool break_node(SplitNode& split, MeshSubset& subset) {break_node194,6230
void local_physics_step(MeshSubset& subset) {local_physics_step233,7317
void perform_breaking(Mesh& mesh) {perform_breaking274,8753

breaking.hpp,42
#define BREAKING_HPPBREAKING_HPP28,1319

bvh.cpp,1495
BOX node_box (const Node *node, bool ccd) {node_box56,1994
BOX vert_box (const Vert *vert, bool ccd) {vert_box64,2128
BOX edge_box (const Edge *edge, bool ccd) {edge_box68,2213
BOX face_box (const Face *face, bool ccd) {face_box75,2365
BOX dilate (const BOX &box, double d) {dilate82,2515
bool overlap (const BOX &box0, const BOX &box1, float thickness) {overlap96,2842
DeformBVHTree::refit()refit101,2969
DeformBVHTree::box()box109,3040
inline vec3f norm(vec3f &p1, vec3f &p2, vec3f &p3)norm114,3091
DeformBVHNode::refit(bool ccd)refit123,3222
DeformBVHNode::find(Face *face)find136,3445
inline float middle_xyz(char xyz, const vec3f &p1, const vec3f &p2, const vec3f &p3)middle_xyz150,3640
class aap {aap161,3874
	char _xyz;_xyz163,3894
	float _p;_p164,3906
	FORCEINLINE aap(const BOX &total) {aap166,3918
	FORCEINLINE bool inside(const vec3f &mid) const {inside181,4232
DeformBVHTree::DeformBVHTree(DeformModel &mdl, bool ccd)DeformBVHTree188,4400
DeformBVHTree::Construct()Construct200,4581
DeformBVHTree::~DeformBVHTree()~DeformBVHTree278,6550
DeformBVHNode::DeformBVHNode()DeformBVHNode288,6744
DeformBVHNode::~DeformBVHNode()~DeformBVHNode297,6871
DeformBVHNode::DeformBVHNode(DeformBVHNode *parent, Face *face, std::map<Face*,BOX>& tri_boxes)DeformBVHNode304,6980
DeformBVHNode::DeformBVHNode(DeformBVHNode *parent, Face **lst, unsigned int lst_num, std::map<Face*,BOX>& tri_boxes, std::map<Face*,vec3f>& tri_centers)DeformBVHNode315,7221

bvh.hpp,2608
#define MAX(MAX53,1923
#define MIN(MIN54,1964
#define FORCEINLINE FORCEINLINE57,2021
typedef Vec3 vec3f;vec3f59,2055
class kDOP18 {kDOP1861,2076
	FORCEINLINE static void getDistances(const vec3f& p,getDistances63,2099
	FORCEINLINE static void getDistances(const vec3f& p, float d[])getDistances74,2348
	FORCEINLINE static float getDistances(const vec3f &p, int i)getDistances84,2552
	float _dist[18];_dist96,2841
	FORCEINLINE kDOP18() {kDOP1898,2860
	FORCEINLINE kDOP18(const vec3f &v) {kDOP18102,2899
	FORCEINLINE kDOP18(const vec3f &a, const vec3f &b) {kDOP18117,3285
	FORCEINLINE bool overlaps(const kDOP18& b) constoverlaps143,4052
	FORCEINLINE bool overlaps(const kDOP18 &b, kDOP18 &ret) constoverlaps153,4249
	FORCEINLINE bool inside(const vec3f &p) constinside165,4501
	FORCEINLINE kDOP18 &operator += (const vec3f &p)operator +=182,4802
	FORCEINLINE kDOP18 &operator += (const kDOP18 &b)operator +=209,5566
	FORCEINLINE kDOP18 operator + ( const kDOP18 &v) constoperator +232,6394
	FORCEINLINE float length(int i) const {length235,6490
	FORCEINLINE float width()  const { return _dist[9] - _dist[0]; }width239,6565
	FORCEINLINE float height() const { return _dist[10] - _dist[1]; }height240,6631
	FORCEINLINE float depth()  const { return _dist[11] - _dist[2]; }depth241,6698
	FORCEINLINE float volume() const { return width()*height()*depth(); }volume242,6765
	FORCEINLINE vec3f center() const { center244,6837
	FORCEINLINE float center(int i) const {center248,6957
	FORCEINLINE void empty() {empty252,7039
#define BOX BOX260,7155
typedef Mesh DeformModel;DeformModel272,7644
class DeformBVHNode {DeformBVHNode274,7671
	BOX _box;_box276,7701
	Face *_face;_face278,7713
	DeformBVHNode *_parent;_parent280,7728
	DeformBVHNode *_left;_left281,7753
	DeformBVHNode *_right;_right282,7776
    bool _active;_active284,7801
	FORCEINLINE DeformBVHNode *getLeftChild() { return _left; }getLeftChild296,8078
	FORCEINLINE DeformBVHNode *getRightChild() { return _right; }getRightChild297,8139
	FORCEINLINE DeformBVHNode *getParent() { return _parent; }getParent298,8202
	FORCEINLINE Face *getFace() { return _face; }getFace300,8263
	FORCEINLINE bool isLeaf() { return _left == NULL; }isLeaf301,8310
	FORCEINLINE bool isRoot() { return _parent == NULL;}isRoot302,8363
class DeformBVHTree {DeformBVHTree307,8450
	DeformModel		*_mdl;_mdl309,8480
	DeformBVHNode	*_root;_root310,8501
	Face **face_buffer;face_buffer311,8524
    bool _ccd;_ccd313,8546
	FORCEINLINE DeformBVHNode *getRoot() { return _root; }getRoot327,8715

cloth.cpp,75
void compute_material (Material& mat, double Y) {compute_material30,1341

cloth.hpp,2250
#define CLOTH_HPPCLOTH_HPP28,1316
struct Material {Material33,1375
    double density; // area densitydensity34,1393
    StretchingSamples dde_stretching;dde_stretching35,1429
    BendingData dde_bending;dde_bending36,1467
    double damping; // stiffness-proportional damping coefficientdamping37,1496
    double strain_min, strain_max; // strain limitsstrain_min38,1562
    double strain_min, strain_max; // strain limitsstrain_max38,1562
    double yield_curv, weakening; // plasticity parametersyield_curv39,1614
    double yield_curv, weakening; // plasticity parametersweakening39,1614
    double yield_stretch, plastic_flow, plastic_limit;yield_stretch40,1673
    double yield_stretch, plastic_flow, plastic_limit;plastic_flow40,1673
    double yield_stretch, plastic_flow, plastic_limit;plastic_limit40,1673
    bool use_dde; // use DDE material filesuse_dde41,1728
    double thickness;thickness42,1772
    double alt_stretching, alt_bending, alt_poisson; // alternative material modelalt_stretching43,1794
    double alt_stretching, alt_bending, alt_poisson; // alternative material modelalt_bending43,1794
    double alt_stretching, alt_bending, alt_poisson; // alternative material modelalt_poisson43,1794
    double toughness, fracture_bend_thickness; // fracture toughnesstoughness44,1877
    double toughness, fracture_bend_thickness; // fracture toughnessfracture_bend_thickness44,1877
struct Remeshing {Remeshing47,1950
    double refine_angle, refine_compression, refine_velocity;refine_angle48,1969
    double refine_angle, refine_compression, refine_velocity;refine_compression48,1969
    double refine_angle, refine_compression, refine_velocity;refine_velocity48,1969
    double size_min, size_max, size_uniform; // size limitssize_min49,2031
    double size_min, size_max, size_uniform; // size limitssize_max49,2031
    double size_min, size_max, size_uniform; // size limitssize_uniform49,2031
    double aspect_min; // aspect ratio controlaspect_min50,2091
    double refine_fracture;refine_fracture51,2138
struct Cloth {Cloth54,2170
    Mesh mesh;mesh55,2185
    std::vector<Material*> materials;    materials56,2200
    Remeshing remeshing;remeshing57,2242

collision.cpp,3395
static const int max_iter = 30;max_iter42,1590
static const double &thickness = ::magic.projection_thickness;thickness43,1622
static double obs_mass;obs_mass45,1686
static bool deform_obstacles;deform_obstacles46,1710
static map<const Node*, Vec3> xold;xold48,1741
static double get_mass (const Node *node) {get_mass50,1778
struct Impact {Impact53,1871
    enum Type {VF, EE} type;Type54,1887
    enum Type {VF, EE} type;VF54,1887
    enum Type {VF, EE} type;EE54,1887
    enum Type {VF, EE} type;type54,1887
    double t;t55,1916
    Node *nodes[4];nodes56,1930
    double w[4];w57,1950
    Vec3 n;n58,1967
    Impact () {}Impact59,1979
    Impact (Type type, const Node *n0, const Node *n1, const Node *n2,Impact60,1996
struct ImpactZone {ImpactZone69,2239
    vector<Node*> nodes;nodes70,2259
    vector<Impact> impacts;impacts71,2284
    bool active;active72,2312
void collision_response (vector<Mesh*> &meshes, const vector<Constraint*> &cons,collision_response93,3089
void update_active (const vector<AccelStruct*> &accs,update_active154,5406
static int nthreads = 0;nthreads194,6995
static vector<Impact> *impacts = NULL;impacts195,7020
vector<Impact> find_impacts (const vector<AccelStruct*> &accs,find_impacts199,7124
void find_face_impacts (const Face *face0, const Face *face1) {find_face_impacts217,7812
bool vf_collision_test (const Vert *vert, const Face *face, Impact &impact) {vf_collision_test235,8556
bool ee_collision_test (const Edge *edge0, const Edge *edge1, Impact &impact) {ee_collision_test247,9024
bool collision_test (Impact::Type type, const Node *node0, const Node *node1,collision_test261,9603
Vec3 pos (const Node *node, double t) {pos306,11387
int solve_cubic (double a, double b, double c, double d, double x[3]) {solve_cubic315,11655
double newtons_method (double a, double b, double c, double d, double x0,newtons_method339,12519
bool operator< (const Impact &impact0, const Impact &impact1) {operator <362,13187
vector<Impact> independent_impacts (const vector<Impact> &impacts) {independent_impacts368,13351
bool conflict (const Impact &i0, const Impact &i1) {conflict384,13852
void add_impacts (const vector<Impact> &impacts, vector<ImpactZone*> &zones) {add_impacts397,14386
ImpactZone *find_or_create_zone (const Node *node, vector<ImpactZone*> &zones) {find_or_create_zone413,15066
void merge_zones (ImpactZone* zone0, ImpactZone *zone1,merge_zones423,15399
struct NormalOpt: public NLConOpt {NormalOpt435,15688
    ImpactZone *zone;zone436,15724
    double inv_m;inv_m437,15746
    NormalOpt (): zone(NULL), inv_m(0) {nvar = ncon = 0;}NormalOpt438,15764
    NormalOpt (ImpactZone *zone): zone(zone), inv_m(0) {NormalOpt439,15822
void apply_inelastic_projection (ImpactZone *zone,apply_inelastic_projection455,16481
void NormalOpt::initialize (double *x) const {initialize462,16692
void NormalOpt::precompute (const double *x) const {precompute467,16841
double NormalOpt::objective (const double *x) const {objective472,16997
void NormalOpt::obj_grad (const double *x, double *grad) const {obj_grad482,17278
double NormalOpt::constraint (const double *x, int j, int &sign) const {constraint490,17545
void NormalOpt::con_grad (const double *x, int j, double factor,con_grad499,17815
void NormalOpt::finalize (const double *x) const {finalize509,18151

collision.hpp,44
#define COLLISION_HPPCOLLISION_HPP28,1320

collisionutil.cpp,1358
AccelStruct::AccelStruct (const Mesh &mesh, bool ccd):AccelStruct35,1466
void collect_leaves (BVHNode *node, map<const Face*,BVHNode*> &leaves) {collect_leaves41,1633
void update_accel_struct (AccelStruct &acc) {update_accel_struct50,1900
void mark_all_inactive (AccelStruct &acc) {mark_all_inactive58,2096
void mark_active (AccelStruct &acc, const Face *face) {mark_active63,2204
void mark_descendants (BVHNode *node, bool active) {mark_descendants68,2329
void mark_ancestors (BVHNode *node, bool active) {mark_ancestors76,2541
void for_overlapping_faces (BVHNode *node, float thickness,for_overlapping_faces82,2695
void for_overlapping_faces (BVHNode *node0, BVHNode *node1, float thickness,for_overlapping_faces92,3110
void for_overlapping_faces (const vector<AccelStruct*> &accs,for_overlapping_faces113,3989
void for_faces_overlapping_obstacles (const vector<AccelStruct*> &accs,for_faces_overlapping_obstacles136,5030
vector<BVHNode*> collect_upper_nodes (const vector<AccelStruct*> &accs,collect_upper_nodes153,5848
vector<AccelStruct*> create_accel_structs (const vector<Mesh*> &meshes,create_accel_structs175,6585
void destroy_accel_structs (vector<AccelStruct*> &accs) {destroy_accel_structs184,6905
const vector<Mesh*> *meshes, *obs_meshes;meshes190,7062
const vector<Mesh*> *meshes, *obs_meshes;obs_meshes190,7062

collisionutil.hpp,822
#define COLLISIONUTIL_HPPCOLLISIONUTIL_HPP28,1324
typedef DeformBVHNode BVHNode;BVHNode33,1386
typedef DeformBVHTree BVHTree;BVHTree34,1417
struct AccelStruct {AccelStruct36,1449
    BVHTree tree;tree37,1470
    BVHNode *root;root38,1488
    std::map<const Face*, BVHNode*> leaves;leaves39,1507
typedef void (*BVHCallback) (const Face *face0, const Face *face1);BVHCallback49,1797
template<> inline bool is_free<Node> (const Node* p) { return p->verts[0]->adjf[0]->material; }is_free72,3019
template<> inline bool is_free<Vert> (const Vert* p) { return p->adjf[0]->material; }is_free73,3115
template<> inline bool is_free<Edge> (const Edge* p) { return p->n[0]->verts[0]->adjf[0]->material; }is_free74,3201
template<> inline bool is_free<Face> (const Face* p) { return p->material; }is_free75,3303

conf.cpp,3668
template <int n> void parse (Vec<n> &v, const Json::Value &json) {parse51,1854
template <typename T> void parse (T &x, const Json::Value &json, const T &x0) {parse58,2066
template <typename T> void parse (vector<T> &v, const Json::Value &json) {parse65,2221
void load_json (const string &configFilename, Simulation &sim) {load_json82,2939
void complain (const Json::Value &json, const string &expected) {complain152,6001
void parse (bool &b, const Json::Value &json) {parse157,6164
void parse (int &n, const Json::Value &json) {parse161,6288
void parse (double &x, const Json::Value &json) {parse165,6414
void parse (string &s, const Json::Value &json) {parse169,6542
struct Range {Range174,6672
    double &min, &max;min175,6687
    double &min, &max;max175,6687
    Range (double &min, double &max): min(min), max(max) {}Range176,6710
void parse (Range range, const Json::Value &json, Vec2 range0) {parse179,6774
struct Box {Box190,7044
    Vec2 umin, umax;umin191,7057
    Vec2 umin, umax;umax191,7057
    Box () {}Box192,7078
    Box (const Vec2 &umin, const Vec2 &umax): umin(umin), umax(umax) {}Box193,7092
void parse (Box &box, const Json::Value &json, const Box &box0) {parse196,7168
struct Velocity {Vec3 v, w; Vec3 o;};Velocity212,7546
struct Velocity {Vec3 v, w; Vec3 o;};v212,7546
struct Velocity {Vec3 v, w; Vec3 o;};w212,7546
struct Velocity {Vec3 v, w; Vec3 o;};o212,7546
void reorient_MS(Mesh& mesh) {reorient_MS216,7686
void reproject_all(Mesh& mesh) {reproject_all228,8087
void parse (Cloth &cloth, const Json::Value &json) {parse235,8266
void parse (Transformation& transform, const Json::Value &json) {parse276,9786
void parse (Velocity &velocity, const Json::Value &json) {parse285,10135
void apply_velocity (Mesh &mesh, const Velocity &vel) {apply_velocity291,10342
void parse (Material *&material, const Json::Value &json) {parse299,10590
void parse (Remeshing &remeshing, const Json::Value &json) {parse348,12819
void parse_motions (vector<Motion> &motions, const Json::Value &json) {parse_motions363,13475
void parse (Motion &motion, const Json::Value &json) {parse385,14288
void parse (Motion::Point &mp, const Json::Value &json) {parse392,14550
void parse_handles (vector<Handle*> &hans, const Json::Value &jsons,parse_handles411,15118
void parse_handle (vector<Handle*> &hans, const Json::Value &json,parse_handle433,16112
void parse_node_handle (vector<Handle*> &hans, const Json::Value &json,parse_node_handle461,17149
void parse_circle_handle (vector<Handle*> &hans, const Json::Value &json,parse_circle_handle495,18260
void parse_soft_handle (vector<Handle*> &hans, const Json::Value &json,parse_soft_handle513,18906
void parse_glue_handle (vector<Handle*> &hans, const Json::Value &json,parse_glue_handle527,19408
void parse_obstacles (vector<Obstacle> &obstacles, const Json::Value &json,parse_obstacles547,20070
void parse_obstacle (Obstacle &obstacle, const Json::Value &json,parse_obstacle572,20989
void parse_morphs (vector<Morph> &morphs, const Json::Value &json,parse_morphs597,21892
void parse_morph (Morph &morph, const Json::Value &json,parse_morph604,22140
void parse (Wind &wind, const Json::Value &json) {parse634,23260
void parse (Magic &magic, const Json::Value &json) {parse640,23453
#define PARSE_MAGIC(PARSE_MAGIC641,23506
#undef PARSE_MAGICPARSE_MAGIC657,24140
void load_material_data (Material &material, const string &filename) {load_material_data665,24282
void parse (StretchingSamples &samples, const Json::Value &json) {parse681,24862
void parse (BendingData &data, const Json::Value &json) {parse691,25181

conf.hpp,34
#define CONF_HPPCONF_HPP28,1315

constraint.cpp,1993
double EqCon::value (int *sign) {value32,1368
MeshGrad EqCon::gradient () {MeshGrad grad; grad.push_back(MeshGradV(node,n)); return grad;}gradient36,1461
MeshGrad EqCon::project () {return MeshGrad();}project37,1554
double EqCon::energy (double value) {return stiff*sq(value)/2.;}energy38,1602
double EqCon::energy_grad (double value) {return stiff*value;}energy_grad39,1667
double EqCon::energy_hess (double value) {return stiff;}energy_hess40,1730
MeshGrad EqCon::friction (double dt, MeshHess &jac) {return MeshGrad();}friction41,1787
bool EqCon::contains(Node* _node) { return node == _node; }contains42,1860
double GlueCon::value (int *sign) {value44,1921
MeshGrad GlueCon::gradient () {gradient48,2030
MeshGrad GlueCon::project () {return MeshGrad();}project54,2187
double GlueCon::energy (double value) {return stiff*sq(value)/2.;}energy55,2237
double GlueCon::energy_grad (double value) {return stiff*value;}energy_grad56,2304
double GlueCon::energy_hess (double value) {return stiff;}energy_hess57,2369
MeshGrad GlueCon::friction (double dt, MeshHess &jac) {return MeshGrad();}friction58,2428
bool GlueCon::contains(Node* _node) { return nodes[0] == _node || nodes[1] == _node; }contains59,2503
double IneqCon::value (int *sign) {value61,2591
MeshGrad IneqCon::gradient () {gradient72,2830
MeshGrad IneqCon::project () {project80,3012
double violation (double value) {return std::max(-value, 0.);}violation95,3488
double IneqCon::energy (double value) {energy97,3552
double IneqCon::energy_grad (double value) {energy_grad101,3681
double IneqCon::energy_hess (double value) {energy_hess104,3798
MeshGrad IneqCon::friction (double dt, MeshHess &jac) {friction108,3909
bool IneqCon::contains(Node *_node) {contains141,4875
template<> void serializer<vector<Constraint*> >(vector<Constraint*>& x, Serialize& s, const string& n) { serializer150,5025
void IneqCon::serializer(Serialize& s, const std::string& name) {serializer156,5222

constraint.hpp,1994
#define CONSTRAINT_HPPCONSTRAINT_HPP28,1321
struct MeshGradV { Node* node; Vec3 f; MeshGradV(Node* i, const Vec3& f) : node(i), f(f) {} };MeshGradV38,1486
struct MeshGradV { Node* node; Vec3 f; MeshGradV(Node* i, const Vec3& f) : node(i), f(f) {} };node38,1486
struct MeshGradV { Node* node; Vec3 f; MeshGradV(Node* i, const Vec3& f) : node(i), f(f) {} };f38,1486
struct MeshGradV { Node* node; Vec3 f; MeshGradV(Node* i, const Vec3& f) : node(i), f(f) {} };MeshGradV38,1486
struct MeshHessV { Node* i; Node* j; Mat3x3 J; MeshHessV(Node *i, Node* j, const Mat3x3& J) : i(i), j(j), J(J) {}};MeshHessV39,1581
struct MeshHessV { Node* i; Node* j; Mat3x3 J; MeshHessV(Node *i, Node* j, const Mat3x3& J) : i(i), j(j), J(J) {}};i39,1581
struct MeshHessV { Node* i; Node* j; Mat3x3 J; MeshHessV(Node *i, Node* j, const Mat3x3& J) : i(i), j(j), J(J) {}};j39,1581
struct MeshHessV { Node* i; Node* j; Mat3x3 J; MeshHessV(Node *i, Node* j, const Mat3x3& J) : i(i), j(j), J(J) {}};J39,1581
struct MeshHessV { Node* i; Node* j; Mat3x3 J; MeshHessV(Node *i, Node* j, const Mat3x3& J) : i(i), j(j), J(J) {}};MeshHessV39,1581
typedef std::vector<MeshGradV> MeshGrad;MeshGrad41,1698
typedef std::vector<MeshHessV> MeshHess;MeshHess42,1739
struct Constraint {Constraint44,1781
    virtual ~Constraint () {};~Constraint45,1801
    virtual void serializer(Serialize& s, const std::string& name) {};serializer58,2283
struct EqCon: public Constraint {EqCon61,2358
    Node *node;node63,2421
    Vec3 x, n;x64,2437
    Vec3 x, n;n64,2437
    double stiff;stiff65,2452
struct GlueCon: public Constraint {GlueCon76,2753
    Node *nodes[2];nodes77,2789
    Vec3 n;n78,2809
    double stiff;stiff79,2821
struct IneqCon: public Constraint {IneqCon90,3126
    Node *nodes[4];nodes92,3200
    double w[4];w93,3220
    bool free[4];free94,3237
    Vec3 n;n95,3255
    double a; // areaa96,3267
    double mu; // frictionmu97,3289
    double stiff;stiff98,3316

dde.cpp,453
static const int nsamples = 30;nsamples34,1382
void evaluate_stretching_samples (StretchingSamples &samples,evaluate_stretching_samples38,1495
Vec4 evaluate_stretching_sample (const Mat2x2 &_G, const StretchingData &data) {evaluate_stretching_sample52,2060
Vec4 stretching_stiffness (const Mat2x2 &G, const StretchingSamples &samples) {stretching_stiffness87,3520
double bending_stiffness (const Edge *edge, int side,bending_stiffness126,4806

dde.hpp,415
#define DDE_HPPDDE_HPP28,1314
typedef Vec<4> Vec4;Vec433,1374
struct StretchingData {Vec4 d[2][5];};StretchingData35,1396
struct StretchingData {Vec4 d[2][5];};d35,1396
struct StretchingSamples {Vec4 s[40][40][40];};StretchingSamples37,1436
struct StretchingSamples {Vec4 s[40][40][40];};s37,1436
struct BendingData {double d[3][5];};BendingData39,1485
struct BendingData {double d[3][5];};d39,1485

display.cpp,3783
bool stepDebug;stepDebug50,1694
vector<Annotation> Annotation::list;list52,1711
Pane Pane::panes[3] = { false, false, true };panes53,1748
int display_mode = 0;display_mode55,1795
struct DisplayMode { string name; double scale; bool active; };DisplayMode56,1817
struct DisplayMode { string name; double scale; bool active; };name56,1817
struct DisplayMode { string name; double scale; bool active; };scale56,1817
struct DisplayMode { string name; double scale; bool active; };active56,1817
DisplayMode display_modes[] = { {"sigma", 1e4, true},display_modes57,1881
Pane* Pane::current() { current64,2221
Vec3 Pane::pos(Vert* v) {pos72,2362
void reshape (int w, int h) {reshape78,2491
void vertex (const Vec2 &x) {vertex96,2985
void vertex (const Vec3 &x) {vertex100,3046
void normal (const Vec3 &n) {normal104,3113
void color (const Vec3 &x) {color108,3180
Vec3 strain_color (const Face *face) {strain_color112,3245
Vec3 plasticity_color (const Face *face) {plasticity_color120,3551
Vec3 origami_color (const Mat3x3& M) {origami_color129,3809
inline double matrix_mag(const Mat3x3& M) {matrix_mag134,3925
Vec3 red_blue_colorscheme(double v) {red_blue_colorscheme141,4127
Vec3 debug_color (Face *face, const Vert* vert) {debug_color149,4456
void draw_mesh_ms (Mesh &mesh, bool set_color=false) {draw_mesh_ms191,6208
void draw_meshes_ms (bool set_color=false) {draw_meshes_ms227,7200
void shrink_face (const Face *face, double shrink_factor, double shrink_max,shrink_face232,7360
void draw_meshes_ms_fancy () {draw_meshes_ms_fancy247,7967
void draw_mesh_ps (const Mesh &mesh, bool set_color=false) {draw_mesh_ps273,8851
void draw_meshes_ps (bool set_color=false) {draw_meshes_ps288,9257
void draw_annotation(Annotation& a) {draw_annotation294,9436
void draw_mesh (const Mesh &mesh, bool set_color=false) {draw_mesh331,10207
void draw_meshes (bool set_color=false) {draw_meshes366,11596
void draw_seam_or_boundary_edges () {draw_seam_or_boundary_edges372,11772
void draw_node_vels () {draw_node_vels388,12250
void draw_node_accels () {draw_node_accels418,13202
void directional_light (int i, const Vec3 &dir, const Vec3 &dif) {directional_light436,13746
void ambient_light (const Vec3 &a) {ambient_light444,14090
double aspect_ratio () {aspect_ratio449,14257
void apply_view (const Pane &view) {apply_view453,14360
void init_view(Pane& view) {init_view462,14659
void display_material () {display_material479,15094
void display_plastic () {display_plastic522,16449
void display_world () {display_world562,17737
struct MouseState {MouseState617,19617
    bool down;down618,19637
    int x, y;x619,19652
    int x, y;y619,19652
    int down_x, down_y;down_x620,19666
    int down_x, down_y;down_y620,19666
    enum {ROTATE, TRANSLATE, SCALE} func;ROTATE621,19690
    enum {ROTATE, TRANSLATE, SCALE} func;TRANSLATE621,19690
    enum {ROTATE, TRANSLATE, SCALE} func;SCALE621,19690
    enum {ROTATE, TRANSLATE, SCALE} func;func621,19690
} mouse_state;mouse_state622,19732
void zoom (bool in) {zoom624,19748
void select_element(int x, int y, int button) {select_element636,19969
void mouse (int button, int state, int x, int y) {mouse709,22871
void motion (int x, int y) {motion748,24247
void nop () {} // apparently needed by GLUT 3.0nop769,24880
void (*keyboard_sub)(unsigned char, int, int);keyboard_sub771,24929
void keyboard_handler(unsigned char key, int x, int y) {keyboard_handler772,24976
void init_glut (const GlutCallbacks &cb) {init_glut793,25595
void run_glut() {run_glut821,26627
void redisplay () {redisplay825,26668
void wait_key () {   wait_key832,26806
std::vector<Annotation> Annotation::list;list842,26973
void wait_key () {}wait_key843,27015

display.hpp,1899
#define DISPLAY_HPPDISPLAY_HPP28,1318
struct GlutCallbacks {GlutCallbacks37,1442
    void (*idle) ();idle38,1465
    void (*keyboard) (unsigned char, int, int);keyboard39,1486
    void (*special) (int, int, int);special40,1534
    GlutCallbacks (): idle(NULL), keyboard(NULL), special(NULL) {}GlutCallbacks41,1571
struct Annotation {Annotation44,1642
	Vec3 color;color45,1662
	Vec3 pos, dir;pos46,1675
	Vec3 pos, dir;dir46,1675
	Face* face;face47,1691
	Edge* edge;edge48,1704
	Node* node;node49,1717
	static void add(Face* f, Vec3 c = Vec3(1,0,0)) { list.push_back(Annotation(f,0,0,c,Vec3(0))); }add51,1731
	static void add(Edge* e, Vec3 c = Vec3(1,0,0)) { list.push_back(Annotation(0,e,0,c,Vec3(0))); }add52,1828
	static void add(Node* n, Vec3 c = Vec3(1,0,0)) { list.push_back(Annotation(0,0,n,c,Vec3(0))); }add53,1925
	static void add(Vec3 pos, Vec3 c = Vec3(1,0,0)) { list.push_back(Annotation(0,0,0,c,pos)); }add54,2022
	static void add(Vec3 pos, Vec3 dir, Vec3 c = Vec3(1,0,0)) { list.push_back(Annotation(0,0,0,c,pos,dir)); }add55,2116
	static std::vector<Annotation> list;list56,2224
	Annotation(Face* f, Edge* e, Node* n, Vec3 c, Vec3 p, Vec3 d=Vec3(0)) : Annotation58,2271
struct Pane {Pane62,2401
	double lat, lon;lat63,2415
	double lat, lon;lon63,2415
    Vec2 offset;offset64,2433
    Vec3 center;center65,2450
    double scale;scale66,2467
    int window, parent;window67,2485
    int window, parent;parent67,2485
    bool enabled;enabled68,2509
    bool initialized;initialized70,2550
    static Pane panes[3];panes73,2601
    static Pane& material() { return panes[0]; }material74,2627
	static Pane& world() { return panes[2]; }world75,2676
	static Pane& plastic() { return panes[1]; }plastic76,2719
    Pane (bool enable): lat(0), lon(0), offset(0), scale(0.5), enabled(enable), initialized(false) {}Pane78,2765

displayphysics.cpp,304
static bool running = false;running50,1695
static void idle () {idle52,1725
static void keyboard (unsigned char key, int x, int y) {keyboard59,1819
void display_physics (const vector<string> &args) {display_physics72,2145
void display_resume (const vector<string> &args) {display_resume97,2952

displayphysics.hpp,54
#define DISPLAYPHYSICS_HPPDISPLAYPHYSICS_HPP28,1325

displayreplay.cpp,553
static int frameskip;frameskip42,1558
static bool running = false;running44,1581
static void reload () {reload46,1611
static void idle () {idle64,2164
static void keyboard (unsigned char key, int x, int y) {keyboard79,2480
static void special (int key, int x, int y) {special88,2685
static void save_obstacle_transforms (const vector<Obstacle> &obs, int frame,save_obstacle_transforms105,3149
void generate_obj (const vector<string> &args) {generate_obj118,3708
void display_replay (const vector<string> &args) {display_replay146,4659

displayreplay.hpp,52
#define DISPLAYREPLAY_HPPDISPLAYREPLAY_HPP28,1324

displaytesting.cpp,341
template <int n> Vec<n> random () {random42,1596
static void recover_plasticity (Mesh &mesh) {recover_plasticity49,1743
static void remeshing_step (Cloth &cloth) {remeshing_step54,1908
static void keyboard (unsigned char key, int x, int y) {keyboard58,2007
void display_testing (const vector<string> &args) {display_testing71,2306

displaytesting.hpp,54
#define DISPLAYTESTING_HPPDISPLAYTESTING_HPP28,1325

dynamicremesh.cpp,2910
static const bool verbose = false;verbose45,1679
void static_remesh (Mesh& mesh) {static_remesh60,2126
void dynamic_remesh (Mesh& mesh, const map<Node*,Plane> &planes) {dynamic_remesh70,2464
void dynamic_remesh (MeshSubset& subset, const map<Node*,Plane> &planes) {dynamic_remesh85,3012
double angle (const Vec3 &n1, const Vec3 &n2) {angle100,3549
template <int n> Mat<n,n> sqrt (const Mat<n,n> &A) {sqrt104,3643
Mat2x2 perp (const Mat2x2 &A) {return Mat2x2(Vec2(A(1,1), -A(1,0)),perp111,3880
Mat2x2 compression_metric (const Face* face, const Mat3x3 &S2, const Mat3x2& UV, double c) {compression_metric114,4019
Mat3x3 obstacle_metric (const Face *face, const map<Node*,Plane> &planes) {obstacle_metric125,4425
Mat2x2 fracture_metric (Remeshing& remeshing, const Face* face) {fracture_metric141,4957
Mat3x3 compute_face_sizing (Remeshing& remeshing, const Face *face, const map<Node*,Plane> &planes,compute_face_sizing160,5567
void create_vert_sizing (vector<Vert*>& verts, const map<Node*,Plane> &planes) {create_vert_sizing229,8281
double edge_metric (const Vert *vert0, const Vert *vert1) {edge_metric248,8955
double edge_metric (const Edge *edge) {edge_metric255,9178
bool flip_some_edges (MeshSubset* subset, vector<Face*>& active_faces, flip_some_edges264,9506
void flip_edges (MeshSubset* subset, vector<Face*>& active_faces, flip_edges290,10330
vector<Edge*> find_edges_to_flip (vector<Face*>& active_faces){find_edges_to_flip302,10712
bool independent (const Edge *edge, const vector<Edge*> &edges) {independent318,11201
vector<Edge*> independent_edges (const vector<Edge*> &edges) {independent_edges328,11539
double cross (const Vec2 &u, const Vec2 &v) {return u[0]*v[1] - u[1]*v[0];}cross336,11781
inline bool should_flip2 (const Vec2& x, const Vec2& y, const Vec2& z, const Vec2& w, should_flip2339,11891
bool should_flip (const Edge *edge) {should_flip346,12218
bool split_worst_edge (MeshSubset* subset, const vector<Edge*>& edges) {split_worst_edge379,13425
struct Deterministic_sort {Deterministic_sort405,14479
    inline bool operator()(const std::pair<double,Edge*> &left, const std::pair<double,Edge*> &right) {operator ()406,14507
} deterministic_sort;deterministic_sort409,14658
vector<Edge*> find_bad_edges (const vector<Edge*>& edges) {find_bad_edges411,14681
Vert *adjacent_vert (const Node *node, const Vert *vert) {adjacent_vert425,15186
bool improve_some_face (MeshSubset* subset, vector<Face*>& active) {improve_some_face440,15601
bool any_nearly_invalid (const vector<Edge*> edges) {any_nearly_invalid464,16447
RemeshOp try_edge_collapse (Edge *edge, int which) {try_edge_collapse470,16624
bool has_labeled_edges (const Node *node) {has_labeled_edges486,17221
bool can_collapse (Remeshing& remeshing, const Edge *edge, int i) {can_collapse493,17401
void delete_spaced_out(Mesh& mesh) {delete_spaced_out519,18527

dynamicremesh.hpp,52
#define DYNAMICREMESH_HPPDYNAMICREMESH_HPP28,1324

geometry.cpp,1860
double signed_vf_distance (const Vec3 &x,signed_vf_distance32,1364
double signed_ve_distance (const Vec3 &x,const Vec3 &y0, const Vec3 &y1,signed_ve_distance52,1986
double signed_ee_distance (const Vec3 &x0, const Vec3 &x1,signed_ee_distance70,2420
bool set_unsigned_ve_distance (const Vec3 &x, const Vec3 &y0, const Vec3 &y1,set_unsigned_ve_distance108,3728
bool set_unsigned_vf_distance (const Vec3 &x,set_unsigned_vf_distance125,4226
bool set_unsigned_ee_distance (const Vec3 &x0, const Vec3 &x1,set_unsigned_ee_distance163,5437
double unsigned_vf_distance (const Vec3 &x,unsigned_vf_distance207,6867
double unsigned_ee_distance (const Vec3 &x0, const Vec3 &x1,unsigned_ee_distance217,7227
Vec3 get_barycentric_coords(const Vec2& point, const Face* f) {get_barycentric_coords227,7589
bool is_inside(const Vec2& point, const Face* f) {is_inside248,8407
Face* get_enclosing_face(const Mesh& mesh, const Vec2& u,get_enclosing_face257,8787
template <Space s> Vec3 normal (const Face *face) {normal265,9046
template <Space s> Vec3 normal (const Node* node) {normal275,9402
double dihedral_angle (const Vec3& p0, const Vec3& p1, const Vec3& n0, const Vec3& n1) {dihedral_angle293,10072
template <Space s> double dihedral_angle (const Edge *edge) {dihedral_angle302,10395
template <Space s> Mat2x2 projected_curvature (const Face *face, const Mat2x3& base) {projected_curvature322,11255
template <Space s> Mat3x3 curvature (const Face *face) {curvature340,11978
double aspect (const Vec3& u0, const Vec3& u1, const Vec3& u2) {aspect360,12696
double get_angle(const Vec3& u, const Vec3& v) {get_angle365,12905
Plane plane_fit(const Mesh& mesh) {plane_fit372,13050
Mat3x3 local_base(const Vec3& normal) {local_base390,13489
bool triangle_ray_test (const Vec3 &x0, const Vec3& x1, const Vec3& x2,triangle_ray_test403,13864

geometry.hpp,1571
#define GEOMETRY_HPPGEOMETRY_HPP28,1319
enum Space {MS, PS, WS}; // material space, plastic space, world spaceSpace57,2370
enum Space {MS, PS, WS}; // material space, plastic space, world spaceMS57,2370
enum Space {MS, PS, WS}; // material space, plastic space, world spacePS57,2370
enum Space {MS, PS, WS}; // material space, plastic space, world spaceWS57,2370
inline double area (const Vec3& u0, const Vec3& u1, const Vec3& u2) { return 0.5*norm(cross(u1-u0,u2-u0)); }area70,3046
inline double area (const Face* face) { return area(face->v[0]->u, face->v[1]->u, face->v[2]->u); }area71,3155
inline double aspect (const Face* face) { return aspect(face->v[0]->u, face->v[1]->u, face->v[2]->u); }aspect73,3319
template <> inline const Vec3 &pos<PS> (const Node *node) {return node->y;}pos87,3824
template <> inline const Vec3 &pos<WS> (const Node *node) {return node->x;}pos88,3900
template <> inline Vec3 &pos<PS> (Node *node) {return node->y;}pos89,3976
template <> inline Vec3 &pos<WS> (Node *node) {return node->x;}pos90,4040
template <> inline const Vec3 &pos<MS> (const Vert *vert) {return vert->u;}pos91,4104
template <> inline const Vec3 &pos<PS> (const Vert *vert) {return vert->node->y;}pos92,4180
template <> inline const Vec3 &pos<WS> (const Vert *vert) {return vert->node->x;}pos93,4262
template <> inline Vec3 &pos<MS> (Vert *vert) {return vert->u;}pos94,4344
template <> inline Vec3 &pos<PS> (Vert *vert) {return vert->node->y;}pos95,4408
template <> inline Vec3 &pos<WS> (Vert *vert) {return vert->node->x;}pos96,4478

handle.cpp,774
static Vec3 directions[3] = {Vec3(1,0,0), Vec3(0,1,0), Vec3(0,0,1)};directions32,1386
Transformation normalize (const Transformation &T) {normalize37,1594
vector<Constraint*> NodeHandle::get_constraints (double t) {get_constraints43,1734
vector<Constraint*> CircleHandle::get_constraints (double t) {get_constraints58,2263
vector<Constraint*> GlueHandle::get_constraints (double t) {get_constraints83,3178
vector<Constraint*> SoftHandle::get_constraints (double t) {get_constraints99,3621
void SoftHandle::add_forces(double t, vector<Vec3> &fext, vector<Mat3x3>& Jext) {add_forces103,3723
vector<Node*> SoftHandle::get_nodes() {get_nodes127,4489
void add_position_constraints (const Node *node, const Vec3 &x, double stiff,add_position_constraints139,4803

handle.hpp,1624
#define HANDLE_HPPHANDLE_HPP28,1317
struct Handle {Handle34,1402
    double start_time, end_time, fade_time;start_time35,1418
    double start_time, end_time, fade_time;end_time35,1418
    double start_time, end_time, fade_time;fade_time35,1418
    virtual ~Handle () {};~Handle36,1462
    bool active (double t) {return t >= start_time && t <= end_time;}active39,1607
    double strength (double t) {strength40,1677
    virtual void add_forces(double t, std::vector<Vec3> &fext, std::vector<Mat3x3>& Jext) {}add_forces46,1903
struct NodeHandle: public Handle {NodeHandle50,2001
    Node *node;node51,2036
    const Motion *motion;motion52,2052
    bool activated;activated53,2078
    Vec3 x0;x054,2098
    NodeHandle (): activated(false) {}NodeHandle55,2111
    std::vector<Node*> get_nodes () {return std::vector<Node*>(1, node);}get_nodes57,2207
struct CircleHandle: public Handle {CircleHandle60,2285
    Mesh *mesh;mesh61,2322
    int label;label62,2338
    const Motion *motion;motion63,2353
    double c; // circumferencec64,2379
    Vec2 u;u65,2410
    Vec3 xc, dx0, dx1;xc66,2422
    Vec3 xc, dx0, dx1;dx066,2422
    Vec3 xc, dx0, dx1;dx166,2422
    std::vector<Node*> get_nodes () {return std::vector<Node*>();}get_nodes68,2502
struct GlueHandle: public Handle {GlueHandle71,2573
    Node* nodes[2];nodes72,2608
    std::vector<Node*> get_nodes () {get_nodes74,2685
struct SoftHandle: public Handle {SoftHandle82,2847
    Mesh *mesh;mesh83,2882
    Vec3 center;center84,2898
    double radius;radius85,2915
    const Motion *motion;motion86,2934

io.cpp,1508
const int FILE_VERSION = 1;FILE_VERSION42,1560
void get_valid_line (istream &in, string &line) {get_valid_line47,1605
void triangle_to_obj (const string &inname, const string &outname) {triangle_to_obj53,1750
void load_obj (Mesh &mesh, const string &filename) {load_obj95,3134
void load_objs (vector<Mesh*> &meshes, const string &prefix) {load_objs180,6361
static double angle (const Vec3 &x0, const Vec3 &x1, const Vec3 &x2) {angle185,6549
vector<Face*> triangulate (const vector<Vert*> &verts) {triangulate191,6737
void save_obj (const Mesh &mesh, const string &filename) {save_obj220,7790
void save_objs (const vector<Mesh*> &meshes, const string &prefix) {save_objs283,10347
template<> void serializer<Simulation>(Simulation& sim, Serialize& s, const string& n) {serializer288,10541
void serialize_header(Serialize& s) {serialize_header298,10909
bool load_state (T& state, const string &prefix) {load_state316,11383
void save_state (T& state, const string &prefix) {save_state330,11694
string obtain_subframe_id() {obtain_subframe_id345,12146
void save_transformation (const Transformation &tr, const string &filename) {save_transformation355,12364
void save_screenshot (const string &filename) {save_screenshot376,13177
void flip_image (int w, int h, unsigned char *pixels) {flip_image405,14205
void save_png (const char *filename, int width, int height,save_png412,14444
void ensure_existing_directory (const std::string &path) {ensure_existing_directory457,16116

io.hpp,105
#define IO_HPPIO_HPP28,1313
void test_state (T& state, const std::string& prefix) {test_state67,2407

lbfgs.cpp,243
static const NLOpt *problem;problem35,1441
void l_bfgs_method (const NLOpt &problem, OptOptions opt, bool verbose) {l_bfgs_method40,1617
static void lbfgs_value_and_grad (const real_1d_array &x, double &value,lbfgs_value_and_grad63,2350

localopt.cpp,1078
struct LocalOpt: public NLOpt {LocalOpt35,1451
	vector<Node*>& nodes;nodes36,1483
    vector<Vec3> x0;x037,1506
    vector<Constraint*> cons;    cons38,1527
    mutable vector<Vec3> F;F39,1561
    mutable SpMat<Mat3x3> J;J40,1589
    const vector<Face*>& faces;faces41,1618
    const vector<Edge*>& edges;    edges42,1650
LocalOpt<s>::LocalOpt(vector<Node*>& nodes, const vector<Face*>& faces, const vector<Edge*>& edges, LocalOpt55,2180
void LocalOpt<s>::initialize (double *x) const {initialize80,2867
void LocalOpt<s>::update(const double* x) const {update86,2986
void LocalOpt<s>::precompute (const double *x) const {precompute92,3154
double LocalOpt<s>::objective (const double *x) const {objective104,3522
void LocalOpt<s>::gradient (const double *x, double *g) const {gradient121,4017
bool LocalOpt<s>::hessian (const double *x, SpMat<double> &H) const {hessian136,4441
void LocalOpt<s>::finalize (const double *x) const {finalize155,5113
void local_opt(vector<Node*>& nodes, vector<Face*>& faces, vector<Edge*>& edges,local_opt160,5202

localopt.hpp,39
#define LOCALOPT_HPPLOCALOPT_HPP2,21

lsnewton.cpp,642
static bool verbose;verbose34,1391
static double norm (const vector<double> &x) {return sqrt(dot(x,x));}norm43,1866
void line_search_newtons_method (const NLOpt &problem, OptOptions opt,line_search_newtons_method45,1937
inline double cb (double x) {return x*x*x;}cb86,3177
double line_search (const vector<double> &x0, const vector<double> &p,line_search88,3222
static void add (vector<double> &v, double a, const vector<double> &x,add133,4640
static void scalar_mult (vector<double> &v, double a, const vector<double> &x) {scalar_mult141,4883
static double dot (const vector<double> &x, const vector<double> &y) {dot148,5061

magic.cpp,27
Magic magic;magic29,1320

magic.hpp,941
#define MAGIC_HPPMAGIC_HPP28,1316
struct Magic {Magic32,1369
    bool fixed_high_res_mesh;fixed_high_res_mesh33,1384
    double handle_stiffness, collision_stiffness;handle_stiffness34,1414
    double handle_stiffness, collision_stiffness;collision_stiffness34,1414
    double repulsion_thickness, projection_thickness;repulsion_thickness35,1464
    double repulsion_thickness, projection_thickness;projection_thickness35,1464
    double edge_flip_threshold;edge_flip_threshold36,1518
    double rib_stiffening;rib_stiffening37,1550
    bool combine_tensors;combine_tensors38,1577
    bool preserve_creases;preserve_creases39,1603
    bool add_jitter;add_jitter40,1630
    double separation_step_size;separation_step_size41,1651
    int relax_method, max_cracks;relax_method42,1684
    int relax_method, max_cracks;max_cracks42,1684
    bool enable_localopt;enable_localopt43,1718
    Magic ():Magic44,1744

main.cpp,48
int main (int argc, char **argv) {main40,1608

mesh.cpp,3080
int uuid_src = 0;uuid_src36,1467
template <typename T1, typename T2> void check (const T1 *p1, const T2 *p2,check38,1486
template <typename T1, typename T2> void not_null (const T1 *p1, const T2 *p2) {not_null45,1780
template <typename T1, typename T2> void not_any_nullnot_any_null51,1968
template <typename T1, typename T2> void not_all_nullnot_all_null61,2329
bool check_that_pointers_are_sane (const Mesh &mesh) {check_that_pointers_are_sane72,2691
bool check_that_contents_are_sane (const Mesh &mesh) {check_that_contents_are_sane113,4283
void compute_ws_data (Face* face) {compute_ws_data136,5084
void compute_ws_data (Node* node) {compute_ws_data151,5610
void compute_ws_data (vector<Face*>& faces) {compute_ws_data170,6244
void compute_ws_data (vector<Node*>& nodes) {compute_ws_data175,6378
void compute_ws_data (Mesh &mesh) {compute_ws_data180,6512
void compute_ms_data (Face* face) {compute_ms_data187,6641
void compute_ms_data (Node* node) {compute_ms_data217,7589
void compute_ms_data (vector<Face*>& faces) {compute_ms_data230,7952
void compute_ms_data (vector<Node*>& nodes) {compute_ms_data236,8114
void compute_ms_data (Mesh &mesh) {compute_ms_data242,8276
void connect (Vert *vert, Node *node) {connect249,8401
void Mesh::add (Vert *vert) {add254,8499
void Mesh::remove (Vert* vert) {remove261,8640
void Mesh::add (Node *node) {add270,8901
void Mesh::remove (Node* node) {remove280,9139
void Mesh::add (Edge *edge) {add289,9400
void Mesh::remove (Edge *edge) {remove297,9610
void add_edges_if_needed (Mesh &mesh, const Face *face) {add_edges_if_needed309,9993
void Mesh::add (Face *face) {add318,10254
void Mesh::remove (Face* face) {remove333,10688
void set_indices (Mesh &mesh) {set_indices345,10986
void set_indices (vector<Mesh*>& meshes) {set_indices356,11361
void mark_nodes_to_preserve (Mesh &mesh) {mark_nodes_to_preserve371,11907
void activate_nodes(vector<Node*>& nodes) {activate_nodes386,12354
void deactivate_nodes(vector<Node*>& nodes) {deactivate_nodes393,12524
void apply_transformation_onto (const Mesh &start_state, Mesh &onto,apply_transformation_onto399,12665
void apply_transformation (Mesh& mesh, const Transformation& tr) {apply_transformation406,12939
void update_x0 (Mesh &mesh) {update_x0410,13056
Mesh deep_copy (Mesh &mesh0) {deep_copy415,13188
void delete_mesh (Mesh &mesh) {delete_mesh452,14714
void Vert::serializer(Serialize& s) {serializer472,15262
void Node::serializer(Serialize& s) {serializer477,15375
void Edge::serializer(Serialize& s) {serializer487,15663
void Face::serializer(Serialize& s) {serializer493,15841
template<class T> void serialize_vector(vector<T*>& v, Serialize &s, const string& id) {serialize_vector500,16044
template<class T> void serialize_link(T*& p, vector<T*>& src, Serialize& s, const string& id) {serialize_link511,16297
template<class T> void serialize_links(vector<T*>& v, vector<T*>& src, Serialize& s, const string& id) {serialize_links518,16499
void Mesh::serializer(Serialize& s) {serializer524,16707

mesh.hpp,5682
#define MESH_HPPMESH_HPP28,1315
struct Plane {Plane49,1647
    Plane() {}Plane50,1662
    Plane(const Vec3& x0, const Vec3& n) : x0(x0), n(n) {}Plane51,1677
    Vec3 x0, n;x052,1736
    Vec3 x0, n;n52,1736
struct Vert {Vert57,1778
    Vec3 u; // material spaceu58,1792
    Node *node; // world spacenode59,1822
    std::vector<Face*> adjf; // adjacent facesadjf61,1877
    int index; // position in mesh.vertsindex62,1924
    Mat3x3 sizing;sizing65,2055
    Vert () : node(0),index(-1) {}Vert67,2094
    explicit Vert (const Vec3 &u):Vert68,2129
struct Node {Node74,2220
	enum NodeFlags { FlagNone = 0, FlagActive = 1, FlagMayBreak = 2, NodeFlags75,2234
	enum NodeFlags { FlagNone = 0, FlagActive = 1, FlagMayBreak = 2, FlagNone75,2234
	enum NodeFlags { FlagNone = 0, FlagActive = 1, FlagMayBreak = 2, FlagActive75,2234
	enum NodeFlags { FlagNone = 0, FlagActive = 1, FlagMayBreak = 2, FlagMayBreak75,2234
                     FlagResolveUni = 4, FlagResolveMax = 8 };FlagResolveUni76,2301
                     FlagResolveUni = 4, FlagResolveMax = 8 };FlagResolveMax76,2301
    int uuid;uuid78,2365
	Mesh* mesh;mesh80,2380
	double sep;sep83,2403
    int label;label85,2417
    int flag;flag86,2432
    std::vector<Vert*> verts;verts87,2446
    Vec3 y; // plastic embeddingy88,2476
    Vec3 x, x0, v; // position, old (collision-free) position, velocityx89,2509
    Vec3 x, x0, v; // position, old (collision-free) position, velocityx089,2509
    Vec3 x, x0, v; // position, old (collision-free) position, velocityv89,2509
    bool preserve; // don't remove this nodepreserve90,2581
    int index; // position in mesh.nodesindex92,2650
    std::vector<Edge*> adje; // adjacent edgesadje93,2691
    Vec3 n; // local normal, approximaten95,2795
    double a, m; // area, massa97,2904
    double a, m; // area, massm97,2904
    Mat3x3 curvature; // filtered curvature for bending fracturecurvature98,2935
    Vec3 acceleration;acceleration100,3023
    Node () : uuid(uuid_src++), sep(0),label(0),flag(0),preserve(false),index(-1),a(0),m(0) {}Node101,3046
    explicit Node (const Vec3 &y, const Vec3 &x, const Vec3 &v, int label, int flag, Node102,3141
    inline bool active() const { return flag & FlagActive; }active107,3389
struct Edge {Edge112,3490
    Node *n[2]; // nodesn113,3504
    int preserve;preserve114,3529
    Face *adjf[2]; // adjacent facesadjf116,3571
    int index; // position in mesh.edgesindex117,3608
    double theta_ideal, damage; // rest dihedral angle, damage parametertheta_ideal119,3672
    double theta_ideal, damage; // rest dihedral angle, damage parameterdamage119,3672
    Edge () : index(-1), theta_ideal(0), damage(0) { n[0]=n[1]=0; adjf[0]=adjf[1]=0; }Edge121,3765
    explicit Edge (Node *node0, Node *node1, double theta_ideal, int preserve):Edge122,3852
struct Face {Face131,4088
    Vert* v[3]; // vertsv132,4102
    Material* material;material133,4127
    int flag;flag134,4151
    Edge *adje[3]; // adjacent edgesadje136,4189
    int index; // position in mesh.facesindex137,4226
    Vec3 n; // local normal, exactn139,4324
    double a, m; // area, massa141,4427
    double a, m; // area, massm141,4427
    Mat3x3 Dm, invDm; // finite element matrixDm142,4458
    Mat3x3 Dm, invDm; // finite element matrixinvDm142,4458
    Mat3x3 Sp_bend; // plastic bending strainSp_bend144,4528
    Mat3x3 Sp_str; // plastic stretchingSp_str145,4574
    Mat3x3 sigma;sigma146,4615
    double damage; // accumulated norm of S_plastic/S_yielddamage147,4633
    Face () : material(0), flag(0), index(-1), a(0), m(0), damage(0) { Face149,4713
    explicit Face (Vert *vert0, Vert *vert1, Vert *vert2, const Mat3x3& ps, Face152,4844
struct Mesh {Mesh163,5183
	ReferenceShape *ref;ref164,5197
	Cloth* parent;parent165,5219
    CollisionProxy* proxy;proxy166,5235
    std::vector<Vert*> verts;verts168,5263
    std::vector<Node*> nodes;nodes169,5293
    std::vector<Edge*> edges;edges170,5323
    std::vector<Face*> faces;faces171,5353
    Mesh() : ref(0), parent(0), proxy(0) {};Mesh182,5678
inline Vec3 derivative (double a0, double a1, double a2, double az, const Face *face) {derivative241,7937
inline Mat3x3 derivative (const Vec3& w0, const Vec3& w1, derivative245,8081
inline Vert* get_vert (const Face* face, const Node* node) {get_vert250,8272
inline Node *other_node (const Edge* edge, const Node* node0) {other_node255,8446
inline Face *adj_face (const Face* face0, int num) {adj_face259,8569
inline Edge *next_edge_ccw(const Edge* edge, Node* center) {next_edge_ccw264,8715
inline Edge *next_edge_cw(const Edge* edge, Node* center) {next_edge_cw275,9021
inline Face *next_face_ccw(const Edge* edge, Node* center) {next_face_ccw286,9324
inline Face *next_face_cw(const Edge* edge, Node* center) {next_face_cw290,9452
inline Edge *get_edge (const Node *n0, const Node *n1) {get_edge294,9579
inline Vert *edge_vert (const Edge *edge, int side, int i) {edge_vert303,9824
inline Vert *edge_opp_vert (const Edge *edge, int side) {edge_opp_vert313,10090
template <> inline const std::vector<Vert*> &get (const Mesh &mesh) {return mesh.verts;}get323,10370
template <> inline const std::vector<Node*> &get (const Mesh &mesh) {return mesh.nodes;}get324,10459
template <> inline const std::vector<Edge*> &get (const Mesh &mesh) {return mesh.edges;}get325,10548
template <> inline const std::vector<Face*> &get (const Mesh &mesh) {return mesh.faces;}get326,10637
template <typename Prim> inline int count_elements (const std::vector<Mesh*>& meshes) {count_elements328,10727

misc.cpp,200
void tri2obj (const vector<string> &args) {tri2obj34,1393
void merge_meshes (const vector<string> &args) {merge_meshes48,1874
void split_meshes (const vector<string> &args) {split_meshes86,3272

misc.hpp,34
#define MISC_HPPMISC_HPP28,1315

morph.cpp,195
Vec3 blend (const vector<Mesh> &targets, const vector<double> &w,blend6,68
Vec3 Morph::pos (double t, const Vec3 &u) const {pos25,654
void apply (const Morph &morph, double t) {apply29,753

morph.hpp,283
#define MORPH_HPPMORPH_HPP2,18
struct Morph {Morph6,58
    Mesh *mesh;mesh7,73
    std::vector<Mesh> targets;targets8,89
    typedef std::vector<double> Weights;Weights9,120
    Spline<Weights> weights;weights10,161
    Spline<double> log_stiffness;log_stiffness11,190

mot_parser.cpp,1513
std::vector<Motion> load_mot (const std::string &filename, double fps) {load_mot36,1424
bool is_all_whitespace(const string& empty) {is_all_whitespace40,1559
size_t num_frames(BodyVector &bodies) {num_frames48,1731
size_t num_bodies(BodyVector &bodies) {num_bodies55,1863
void append_frame(BodyVector &bodies, size_t body_index, const BodyFrame& bf) {append_frame59,1932
void resize(BodyVector &bodies, size_t nbodies, size_t nframes) {resize69,2272
BodyVector read_motion_file(const string& filename) {read_motion_file78,2455
BodyVector read_motion_file(std::istream& istr) {read_motion_file87,2719
void write_motion_file(BodyVector &bodies, const string& filename) {write_motion_file151,4225
void write_motion_file(BodyVector &bodies, ostream& ostr) {write_motion_file159,4399
BodyFrame& get_body_frame(BodyVector &bodies, size_t body_index, size_t frame) {get_body_frame185,5246
BodyFrameVector& get_body_frames(BodyVector &bodies, size_t body_index) {get_body_frames194,5534
Transformation bodyframe_to_transformation(const BodyFrame& bodyFrame) {bodyframe_to_transformation201,5762
vector<vector<Transformation> > body_vector_to_transforms(BodyVector& bodies) {body_vector_to_transforms211,6105
vector<vector<Transformation> > mot_to_transforms(string motion_file) {mot_to_transforms225,6740
Spline<Transformation> build_cubic_spline(build_cubic_spline233,7052
vector<Spline<Transformation> > mot_to_spline(string motion_file, const Transformation& tr,mot_to_spline252,7813

mot_parser.hpp,507
#define MOT_PARSER_HPPMOT_PARSER_HPP28,1321
typedef Vec<4> Vec4;Vec441,1597
class mot_parser_exception {mot_parser_exception43,1619
    mot_parser_exception(const std::string& error) : error(error) {}mot_parser_exception45,1656
    std::string error;error46,1725
struct BodyFrameBodyFrame49,1752
    Vec3 pos;pos51,1771
    Vec4 orient;orient52,1785
typedef std::vector<BodyFrame> BodyFrameVector;BodyFrameVector55,1806
typedef std::vector<BodyFrameVector> BodyVector; BodyVector56,1854

nearobs.cpp,840
template <typename T> struct Min {Min36,1459
    double key;key37,1494
    T val;val38,1510
    Min (): key(infinity), val() {}Min39,1521
    void add (double key, T val) {add40,1557
map<Node*, Plane> nearest_obstacle_planes (const vector<Node*>& nodes, nearest_obstacle_planes51,1805
struct NearPoint {NearPoint70,2490
    double d;d71,2509
    Vec3 x;x72,2523
    NearPoint (double d, const Vec3 &x): d(d), x(x) {}NearPoint73,2535
Vec3 nearest_point (const Vec3 &x, const vector<AccelStruct*> &accs,nearest_point78,2667
void update_nearest_point (const Vec3 &x, BVHNode *node, NearPoint &p) {update_nearest_point91,3081
double point_box_distance (const Vec3 &x, const BOX &box) {point_box_distance103,3464
void update_nearest_point (const Vec3 &x, const Face *face, NearPoint &p) {update_nearest_point110,3783

nearobs.hpp,40
#define NEAROBS_HPPNEAROBS_HPP28,1318

nlcg.cpp,269
static const NLOpt *problem;problem35,1441
void nonlinear_conjugate_gradient_method (const NLOpt &problem, OptOptions opt,nonlinear_conjugate_gradient_method40,1615
static void nlcg_value_and_grad (const real_1d_array &x, double &value,nlcg_value_and_grad63,2398

obstacle.cpp,262
Mesh& Obstacle::get_mesh() {get_mesh35,1422
const Mesh& Obstacle::get_mesh() const {get_mesh39,1482
Mesh& Obstacle::get_mesh(double time) {get_mesh43,1554
void Obstacle::blend_with_previous (double t, double dt, double blend) {blend_with_previous68,2468

obstacle.hpp,455
#define OBSTACLE_HPPOBSTACLE_HPP28,1319
struct Obstacle {Obstacle37,1560
    double start_time, end_time;start_time39,1586
    double start_time, end_time;end_time39,1586
    bool activated;activated40,1619
    const Motion *transform_spline;transform_spline52,1994
    Mesh base_mesh;base_mesh55,2091
    Mesh curr_state_mesh;curr_state_mesh57,2163
    Obstacle (): start_time(0), end_time(infinity), activated(false) {}Obstacle59,2190

opengl.hpp,143
#define OPENGL_HPPOPENGL_HPP28,1317
#define GL_GLEXT_PROTOTYPESGL_GLEXT_PROTOTYPES32,1356
inline void opengl_fail () {opengl_fail58,1821

optimization.hpp,2131
#define OPTIMIZATION_HPPOPTIMIZATION_HPP28,1323
struct NLOpt { // nonlinear optimization problemNLOpt35,1408
    int nvar;nvar37,1483
    virtual void precompute (const double *x) const {}precompute40,1606
    virtual bool hessian (const double *x, SpMat<double> &H) const {hessian42,1727
struct NLConOpt { // nonlinear constrained optimization problemNLConOpt48,1921
    int nvar, ncon;nvar50,2038
    int nvar, ncon;ncon50,2038
    virtual void precompute (const double *x) const {}precompute52,2109
struct OptOptions {OptOptions63,2590
    int _max_iter;_max_iter64,2610
    double _eps_x, _eps_f, _eps_g;_eps_x65,2629
    double _eps_x, _eps_f, _eps_g;_eps_f65,2629
    double _eps_x, _eps_f, _eps_g;_eps_g65,2629
    OptOptions (): _max_iter(100), _eps_x(1e-6), _eps_f(1e-12), _eps_g(1e-6) {}OptOptions66,2664
    OptOptions &max_iter (int n) {_max_iter = n; return *this;}max_iter69,2845
    OptOptions &eps_x (double e) {_eps_x = e; return *this;}eps_x70,2909
    OptOptions &eps_f (double e) {_eps_f = e; return *this;}eps_f71,2970
    OptOptions &eps_g (double e) {_eps_g = e; return *this;}eps_g72,3031
    int max_iter () {return _max_iter;}max_iter73,3092
    double eps_x () {return _eps_x;}eps_x74,3132
    double eps_f () {return _eps_f;}eps_f75,3169
    double eps_g () {return _eps_g;}eps_g76,3206
inline Vec3 get_subvec (const double *x, int i) {get_subvec101,4159
inline void set_subvec (double *x, int i, const Vec3 &xi) {set_subvec103,4257
inline void add_subvec (double *x, int i, const Vec3 &xi) {add_subvec105,4368
template <int n> Vec<n> get_subvec (const double *x, int i) {get_subvec108,4481
template <int n> void set_subvec (double *x, int i, const Vec<n> &xi) {set_subvec110,4613
template <int n> void add_subvec (double *x, int i, const Vec<n> &xi) {add_subvec112,4736
inline Mat3x3 get_submat (SpMat<double> &A, int i, int j) {get_submat115,4861
inline void set_submat (SpMat<double> &A, int i, int j, const Mat3x3 &Aij) {set_submat121,5061
inline void add_submat (SpMat<double> &A, int i, int j, const Mat3x3 &Aij) {add_submat125,5246

physics.cpp,3040
static const bool verbose = false;verbose38,1486
static void consistency(vector<Vec3>& b, const string& name) {consistency42,1588
typedef Mat<9,9> Mat9x9;Mat9x949,1750
typedef Mat<9,6> Mat9x6;Mat9x650,1775
typedef Mat<6,6> Mat6x6;Mat6x651,1800
typedef Mat<4,6> Mat4x6;Mat4x652,1825
typedef Mat<3,4> Mat3x4;Mat3x453,1850
typedef Mat<4,9> Mat4x9;Mat4x954,1875
typedef Vec<9> Vec9;Vec955,1900
Mat<m*p,n*q> kronecker (const Mat<m,n> &A, const Mat<p,q> &B) {kronecker62,2144
template <int m> Mat<m,1> colmat (const Vec<m> &v) {colmat72,2449
template <int n> Mat<1,n> rowmat (const Vec<n> &v) {rowmat74,2572
Mat3x3 deformation_gradient (const Face *face) {deformation_gradient78,2715
Mat3x3 material_model (const Face *face, const Mat3x3& G) {material_model83,2929
double stretching_energy (const Face *face) {stretching_energy100,3625
pair<Mat9x9,Vec9> stretching_force (const Face *face) {stretching_force109,3873
typedef Mat<12,12> Mat12x12;Mat12x12171,6771
typedef Vec<12> Vec12;Vec12172,6800
double bending_coeff(const Edge* edge, double theta) {bending_coeff174,6824
double bending_energy (const Edge *edge) {bending_energy193,7579
double distance (const Vec3 &x, const Vec3 &a, const Vec3 &b) {distance201,7803
Vec2 barycentric_weights (const Vec3 &x, const Vec3 &a, const Vec3 &b) {barycentric_weights208,8002
pair<Mat12x12,Vec12> bending_force (const Edge *edge) {bending_force215,8177
template <int m, int n> Mat<3,3> submat3 (const Mat<m,n> &A, int i, int j) {submat3238,9214
template <int n> Vec<3> subvec3 (const Vec<n> &b, int i) {subvec3246,9437
template <int m> void add_submat (const Mat<m*3,m*3> &Asub, const Vec<m,int> &ix, SpMat<Mat3x3> &A) {add_submat253,9591
template <int m> void add_subvec (const Vec<m*3> &bsub, const Vec<m,int> &ix, vector<Vec3> &b) {add_subvec263,9904
Vec<3,int> indices (const Node *n0, const Node *n1, const Node *n2) {indices270,10115
Vec<4,int> indices (const Node *n0, const Node *n1,indices278,10351
double internal_energy (const vector<Face*>& faces, const vector<Edge*>& edges) {internal_energy289,10685
void add_internal_forces (const vector<Face*>& faces, const vector<Edge*>& edges,add_internal_forces305,11236
double constraint_energy (const vector<Constraint*> &cons) {constraint_energy354,13399
void add_constraint_forces (const vector<Constraint*> &cons,add_constraint_forces364,13650
void add_friction_forces (const vector<Constraint*> cons,add_friction_forces400,15025
vector<Vec3> implicit_update (vector<Node*>& nodes, const vector<Edge*>& edges, const vector<Face*>& faces,implicit_update420,15794
Vec3 wind_force (const Face *face, const Wind &wind) {wind_force452,16946
void add_external_forces (const vector<Node*>& nodes, const vector<Face*>& faces, const Vec3 &gravity,add_external_forces461,17292
void add_morph_forces (const Cloth &cloth, const Morph &morph, double t,add_morph_forces476,17860
void project_outside (vector<Node*>& nodes, const vector<Constraint*> &cons) {project_outside496,18732

physics.hpp,40
#define PHYSICS_HPPPHYSICS_HPP28,1318

plasticity.cpp,1620
static const double mu = 1e-6;mu36,1440
void reset_plasticity (Cloth &cloth) {reset_plasticity40,1529
void plastic_update (Cloth &cloth) {plastic_update59,2108
struct EmbedOpt: public NLOpt {EmbedOpt77,2719
    Cloth &cloth;cloth78,2751
    Mesh &mesh;mesh79,2769
    vector<Vec3> y0;y080,2785
    mutable vector<Vec3> f;f81,2806
    mutable SpMat<Mat3x3> J;J82,2834
    EmbedOpt (Cloth &cloth): cloth(cloth), mesh(cloth.mesh) {EmbedOpt83,2863
void optimize_plastic_embedding (Cloth &cloth) {optimize_plastic_embedding103,3575
void EmbedOpt::initialize (double *x) const {initialize111,3896
void EmbedOpt::precompute (const double *x) const {precompute116,4033
double EmbedOpt::objective (const double *x) const {objective127,4399
void EmbedOpt::gradient (const double *x, double *g) const {gradient133,4629
bool EmbedOpt::hessian (const double *x, SpMat<double> &H) const {hessian140,4831
void EmbedOpt::finalize (const double *x) const {finalize153,5261
void reduce_stretching_stiffnesses (vector<Material*> &materials) {reduce_stretching_stiffnesses158,5420
void restore_stretching_stiffnesses (vector<Material*> &materials) {restore_stretching_stiffnesses166,5735
Mat3x3 edges_to_face (const Vec3 &theta, const Face *face) {edges_to_face176,6124
Vec3 face_to_edges (const Mat3x3 &S, const Face *face) {face_to_edges189,6525
void recompute_edge_plasticity (Mesh &mesh) {recompute_edge_plasticity204,7032
void recompute_Sp_bend (Face *face) {recompute_Sp_bend228,7852
Mat3x3 stretch_plasticity_from_embedding(const Face *face) {stretch_plasticity_from_embedding237,8148

plasticity.hpp,46
#define PLASTICITY_HPPPLASTICITY_HPP28,1321

popfilter.cpp,931
static double mu;mu37,1539
struct PopOpt: public NLOpt {PopOpt39,1558
    Cloth &cloth;cloth46,1860
    Mesh &mesh;mesh47,1878
    const vector<Constraint*> &cons;cons48,1894
    vector<Vec3> x0, a0;x049,1931
    vector<Vec3> x0, a0;a049,1931
    mutable vector<Vec3> f;f50,1956
    mutable SpMat<Mat3x3> J;J51,1984
    PopOpt (Cloth &cloth, const vector<Constraint*> &cons):PopOpt52,2013
void apply_pop_filter (Cloth &cloth, const vector<Constraint*> &cons,apply_pop_filter76,2848
void PopOpt::initialize (double *x) const {initialize89,3332
void PopOpt::precompute (const double *x) const {precompute94,3465
double PopOpt::objective (const double *x) const {objective105,3882
void PopOpt::gradient (const double *x, double *g) const {gradient118,4369
bool PopOpt::hessian (const double *x, SpMat<double> &H) const {hessian126,4631
void PopOpt::finalize (const double *x) const {finalize139,5055

popfilter.hpp,44
#define POPFILTER_HPPPOPFILTER_HPP28,1320

proximity.cpp,2363
template <typename T> struct Min {Min38,1503
    double key;key39,1538
    T val;val40,1554
    Min (): key(infinity), val() {}Min41,1565
    void add (double key, T val) {add42,1601
template<class T> void serialize_minvec(vector<Min<T*> >& v, Serialize& s, const string& name) {serialize_minvec53,1801
template<> void serializer<vector<Min<Face*> > >(vector<Min<Face*> >& x, Serialize& s, const string& n) { serialize_minvec(x,s,n); }serializer61,2075
template<> void serializer<vector<Min<Edge*> > >(vector<Min<Edge*> >& x, Serialize& s, const string& n) { serialize_minvec(x,s,n); }serializer62,2208
template<> void serializer<vector<Min<Node*> > >(vector<Min<Node*> >& x, Serialize& s, const string& n) { serialize_minvec(x,s,n); }serializer63,2341
static vector< Min<Face*> > node_prox[2];node_prox65,2475
static vector< Min<Edge*> > edge_prox[2];edge_prox66,2517
static vector< Min<Node*> > face_prox[2];face_prox67,2559
static vector< Min<Node*> > edge_node_prox;edge_node_prox68,2601
static vector< Min<Edge*> > node_edge_prox;node_edge_prox69,2645
vector<Constraint*> proximity_constraints (vector<Mesh*> &meshes,proximity_constraints80,3210
void find_proximities (const Face *face0, const Face *face1) {find_proximities173,6602
static inline bool has_node(const Face* f, const Node* n) {has_node186,7105
static inline Vec3 get_outwards_normal(const Edge *e) {get_outwards_normal190,7250
void add_proximity(Node *node, Edge* edge) {add_proximity199,7577
void add_proximity (const Node *node, const Face *face) {add_proximity222,8355
bool in_wedge (double w, const Edge *edge0, const Edge *edge1) {in_wedge243,9045
void add_proximity (const Edge *edge0, const Edge *edge1) {add_proximity257,9497
Constraint *make_constraint (const Node *node, const Face *face,make_constraint288,10631
Constraint *make_constraint (const Edge *edge0, const Edge *edge1,make_constraint308,11454
Constraint *make_constraint (const Edge* edge, const Node* node, double mu, double mu_obs) {make_constraint328,12275
void make_proxy_constraints (Mesh& mesh, CollisionProxy& proxy, vector<Constraint*>& cons) {make_proxy_constraints349,13081
double area_cached (const Node *node) {area_cached358,13336
double area_cached (const Edge *edge) {area_cached368,13626
double area_cached (const Face *face) {area_cached377,13819

proximity.hpp,44
#define PROXIMITY_HPPPROXIMITY_HPP28,1320

proxy.cpp,244
FloorProxy::FloorProxy(Mesh& mesh){FloorProxy36,1468
CollisionProxy* FloorProxy::clone(Mesh& mesh) {clone40,1525
Constraint* FloorProxy::constraint(const Node* node) {constraint44,1609
void FloorProxy::update(Mesh& mesh) {update67,2188

proxy.hpp,234
#define PROXY_HPPPROXY_HPP28,1316
class CollisionProxy {CollisionProxy36,1454
    virtual ~CollisionProxy() {};~CollisionProxy38,1485
class FloorProxy : public CollisionProxy {FloorProxy44,1673
    Node center;center52,1876

referenceshape.cpp,822
ReferenceSphere::ReferenceSphere(const Vec3& _center, double _radius) : center(_center), radius(_radius) {ReferenceSphere5,53
ReferenceSphere::ReferenceSphere(const Mesh& mesh) {ReferenceSphere9,236
Vec3 ReferenceSphere::closest_point(const Vec3& p) {closest_point28,821
bool ReferenceSphere::raycast(Vec3& p, const Vec3& dir) {raycast32,929
ReferenceLinear::ReferenceLinear(const Mesh& mesh) {    ReferenceLinear37,1054
Vec3 ReferenceLinear::closest_point(const Vec3& p) {closest_point41,1115
bool ReferenceLinear::raycast(Vec3& p, const Vec3& dir) {raycast45,1185
ReferenceMesh::ReferenceMesh(const Mesh& mesh, const string& filename) {  ReferenceMesh49,1263
Vec3 ReferenceMesh::closest_point(const Vec3& p) {closest_point54,1421
bool ReferenceMesh::raycast(Vec3& p, const Vec3& dir) {raycast58,1489

referenceshape.hpp,367
#define REFERENCESHAPE_HPPREFERENCESHAPE_HPP2,27
class ReferenceShape {ReferenceShape6,76
class ReferenceSphere : public ReferenceShape {ReferenceSphere12,223
    Vec3 center;center20,472
    double radius;radius21,489
class ReferenceLinear : public ReferenceShape {ReferenceLinear24,512
class ReferenceMesh : public ReferenceShape {ReferenceMesh32,700

remesh.cpp,2283
template <class T> static void delete_all(const vector<T>& a) { for(size_t i=0; i<a.size(); i++) delete a[i]; }delete_all46,1651
template <class T> static void remove_all(const vector<T>& a, Mesh& m) { for(size_t i=0; i<a.size(); i++) m.remove(a[i]); }remove_all47,1763
template <class T> static void add_all(const vector<T>& a, Mesh& m) { for(size_t i=0; i<a.size(); i++) m.add(a[i]); }add_all48,1887
template <class T> static void include_all(const vector<T>& a, vector<T>& b) { for(size_t i=0; i<a.size(); i++) include(a[i],b); }include_all49,2005
template <class T> static void exclude_all(const vector<T>& a, vector<T>& b) { for(size_t i=0; i<a.size(); i++) exclude(a[i],b); }exclude_all50,2136
RemeshOp RemeshOp::inverse () const {inverse52,2268
void RemeshOp::cancel() {cancel65,2639
void RemeshOp::apply (Mesh &mesh) const {apply80,2980
void RemeshOp::done () const {done96,3515
void RemeshOp::set_null(std::vector<Edge*>& v) {set_null103,3661
void RemeshOp::update(std::vector<Face*>& v) {update109,3795
void RemeshOp::update(std::vector<Edge*>& v) {update114,3907
void RemeshOp::update(std::vector<Node*>& v) {update119,4025
ostream &operator<< (ostream &out, const RemeshOp &op) {operator <<124,4143
Vec3 safe_normal(Face* face) {safe_normal135,4546
void project_vertex(Vert *vnew, Edge* edge, int s, double d) {project_vertex145,4867
void embedding_from_plasticity (const vector<Face*> &fs) {embedding_from_plasticity162,5382
void plasticity_from_embedding (const vector<Face*> &faces) {plasticity_from_embedding186,6227
struct PlasticityStash {PlasticityStash211,7151
    vector<Mat3x3> Sp_str;Sp_str212,7176
    vector<double> theta_ideal;theta_ideal213,7203
    PlasticityStash (vector<Face*> &faces, vector<Edge*> &edges)PlasticityStash214,7235
    void apply (vector<Face*> &faces, vector<Edge*> &edges) {apply227,7742
void optimize_node (Node *node) {optimize_node237,8044
void local_pop_filter (const vector<Face*> &fs) {local_pop_filter255,8635
RemeshOp split_edge (Edge* edge, double d) {split_edge292,9966
RemeshOp collapse_edge (Edge* edge, int i) {collapse_edge345,12107
RemeshOp flip_edge (Edge* edge) {flip_edge402,14432
bool try_move_node (Node* node, Edge* edge, double d) {try_move_node425,15563

remesh.hpp,736
#define REMESH_HPPREMESH_HPP28,1317
struct RemeshOp {RemeshOp35,1445
    std::vector<Vert*> added_verts, removed_verts;added_verts36,1463
    std::vector<Vert*> added_verts, removed_verts;removed_verts36,1463
    std::vector<Node*> added_nodes, removed_nodes;added_nodes37,1514
    std::vector<Node*> added_nodes, removed_nodes;removed_nodes37,1514
    std::vector<Edge*> added_edges, removed_edges;added_edges38,1565
    std::vector<Edge*> added_edges, removed_edges;removed_edges38,1565
    std::vector<Face*> added_faces, removed_faces;added_faces39,1616
    std::vector<Face*> added_faces, removed_faces;removed_faces39,1616
    bool empty () {return added_faces.empty() && removed_faces.empty();}empty40,1667

runphysics.cpp,787
static fstream timingfile;timingfile43,1597
Simulation sim;sim45,1625
int frame;frame46,1641
Timer fps;fps47,1652
void init_physics (const string &json_file, string outprefix,init_physics51,1725
void init_relax() {init_relax69,2521
static void save (vector<Mesh*> &meshes, int frame) {save74,2638
static void save_timings () {save_timings79,2812
void save (Simulation &sim, int frame) {save91,3230
void sim_step() {sim_step95,3309
void offline_loop() {offline_loop107,3618
void run_physics (const vector<string> &args) {run_physics112,3680
void init_resume(const vector<string> &args) {init_resume132,4388
void resume_physics (const vector<string> &args) {resume_physics150,5141
void copy_file (const string &input, const string &output) {copy_file163,5588

runphysics.hpp,46
#define RUNPHYSICS_HPPRUNPHYSICS_HPP28,1321

separate.cpp,3410
static const double &thickness = ::magic.projection_thickness;thickness41,1544
static double obs_mass;obs_mass43,1608
static bool deform_obstacles;deform_obstacles44,1632
static double get_mass (const Node *node) {get_mass45,1662
typedef Vec3 Bary; // barycentric coordinatesBary48,1755
typedef std::pair<Vec3, Vec3> Line3;Line349,1801
struct Ixn {  // intersectionIxn51,1839
    Face *f0, *f1;f052,1869
    Face *f0, *f1;f152,1869
    double l;l53,1888
    Vec3 g0[3], g1[3]; // dl/dx for each of the faces' nodesg054,1902
    Vec3 g0[3], g1[3]; // dl/dx for each of the faces' nodesg154,1902
    Ixn () {}Ixn55,1963
    Ixn (const Face *f0, const Face *f1)Ixn56,1977
void separate (vector<Mesh*> &meshes, const vector<Mesh*> &obs_meshes) {separate80,2907
void compute_length_and_gradient (Ixn &ixn) {compute_length_and_gradient230,8575
void add_gradient (const Face *face0, const Edge *edge0, const Face *face1,add_gradient271,10072
struct EdgeClipping {EdgeClipping297,11037
    double t[2];t298,11059
    Edge *edge[2]; // edges causing clipedge299,11076
    EdgeClipping () {t[0] = 0; t[1] = 1; edge[0] = edge[1] = NULL;}EdgeClipping300,11117
    bool empty () {return t[0] > t[1];}empty301,11185
double compute_coplanar (const Face *face0, const Edge *edge0,compute_coplanar306,11299
EdgeClipping clip_edge_to_face (const Edge *edge, const Face *face) {clip_edge_to_face340,12700
Bary barycentric_coords (const Vec3 &x, const Face *face) {barycentric_coords373,13785
Vec3 pos (const Face *face, const Bary &b) {pos385,14121
void update_active (const vector<AccelStruct*> &accs,update_active391,14278
static int nthreads = 0;nthreads407,14856
static vector<Ixn> *ixns = NULL;ixns408,14881
vector<Ixn> find_intersections (const vector<AccelStruct*> &accs,find_intersections412,14984
vector<Ixn> find_overlappings (const vector<AccelStruct*> &accs,find_overlappings430,15643
void find_face_intersection (const Face *face0, const Face *face1) {find_face_intersection450,16306
void find_face_overlappings (const Face *face0, const Face *face1) {find_face_overlappings461,16591
bool adjacent (const Face *face0, const Face *face1) {adjacent468,16789
bool intersection_midpoint (const Face *face0, const Face *face1,intersection_midpoint480,17169
struct cmpOneAxis {cmpOneAxis502,18086
    size_t axis;axis503,18106
    cmpOneAxis(size_t axis)cmpOneAxis505,18124
    bool operator() (const Vec3& lhs, const Vec3& rhs) const {operator ()507,18176
bool get_line_of_intersection (const Face *face0, const Face *face1, Line3& line) {get_line_of_intersection512,18287
bool face_plane_intersection (const Face *face, const Face *plane,face_plane_intersection547,19404
bool edge_face_intersection (const Vec3& e0, const Vec3& e1,edge_face_intersection572,20139
bool edge_face_intersection (const Edge* edge, const Face *face, Vec3& pt) {edge_face_intersection598,20965
int major_axis (const Vec3 &v) {major_axis612,21371
struct UnionFind {UnionFind617,21515
    vector<size_t> parent, rank;parent618,21534
    vector<size_t> parent, rank;rank618,21534
    UnionFind (size_t n): parent(n), rank(n, 0) {UnionFind619,21567
    size_t find (size_t i) {find622,21677
    void unify (size_t x, size_t y) {unify627,21807
vector< vector<Node*> > connected_components (const vector<Ixn> &ixns) {connected_components642,22147

separate.hpp,42
#define SEPARATE_HPPSEPARATE_HPP28,1319

separateobs.cpp,2892
namespace SO {SO38,1510
static const int max_iter = 100;max_iter40,1526
static map<const Node*, Vec3> xold;xold42,1560
static map<const Face*, Vec3> nold;nold43,1596
typedef Vec3 Bary; // barycentric coordinatesBary45,1633
struct Ixn {// intersectionIxn47,1680
    Face *f0, *f1;f048,1708
    Face *f0, *f1;f148,1708
    Bary b0, b1;b049,1727
    Bary b0, b1;b149,1727
    Vec3 n;n50,1744
    Ixn () {}Ixn51,1756
    Ixn (const Face *f0, const Bary &b0, const Face *f1, const Bary &b1,Ixn52,1770
ostream &operator<< (ostream &out, const Ixn &ixn) {out << ixn.f0 << "@" << ixn.b0 << " " << ixn.f1 << "@" << ixn.b1 << " " << ixn.n; return out;}operator <<56,1926
void build_face_normal_lookup(map<const Face*,Vec3>& nmap, const vector<Mesh*>& meshes) {build_face_normal_lookup65,2337
void separate_obstacles (vector<Mesh*> &obs_meshes,separate_obstacles72,2583
Vec3 pos (const Face *face, const Bary &b) {pos109,3797
void update_active (const vector<AccelStruct*> &accs, const vector<Ixn> &ixns) {update_active114,3945
static int nthreads = 0;nthreads127,4426
static vector<Ixn> *ixns = NULL;ixns128,4451
vector<Ixn> find_intersections (const vector<AccelStruct*> &accs,find_intersections132,4554
void find_face_intersection (const Face *face0, const Face *face1) {find_face_intersection154,5369
bool adjacent (const Face *face0, const Face *face1) {adjacent167,5807
bool intersection_midpoint (const Face *face0, const Face *face1,intersection_midpoint179,6187
bool face_plane_intersection (const Face *face, const Face *plane,face_plane_intersection201,7104
int major_axis (const Vec3 &v) {major_axis226,7839
bool farthest_points (const Face *face0, const Face *face1, const Vec3 &d,farthest_points236,8272
double vf_clear_distance (const Face *face0, const Face *face1, const Vec3 &d,vf_clear_distance245,8660
double ee_clear_distance (const Face *face0, const Face *face1, const Vec3 &d,ee_clear_distance272,9595
struct SeparationOpt: public NLConOpt {SeparationOpt305,10885
    const vector<Ixn> &ixns;ixns306,10925
    vector<Node*> nodes;nodes307,10954
    double inv_m;inv_m308,10979
    SeparationOpt (const vector<Ixn> &ixns): ixns(ixns), inv_m(0) {SeparationOpt309,10997
void solve_ixns (const vector<Ixn> &ixns) {solve_ixns328,11739
void SeparationOpt::initialize (double *x) const {initialize332,11840
double SeparationOpt::objective (const double *x) const {objective337,11981
void SeparationOpt::obj_grad (const double *x, double *grad) const {obj_grad347,12253
double SeparationOpt::constraint (const double *x, int j, int &sign) const {constraint355,12510
void SeparationOpt::con_grad (const double *x, int j, double factor,con_grad370,13036
void SeparationOpt::finalize (const double *x) const {finalize383,13493
void separate_obstacles (vector<Mesh*> &obs_meshes,separate_obstacles390,13643

separateobs.hpp,48
#define SEPARATEOBS_HPPSEPARATEOBS_HPP28,1322

sepstrength.cpp,516
struct FanPrecomp {FanPrecomp8,120
	Vec3 t0, t1;t09,140
	Vec3 t0, t1;t19,140
	Vec3 frame_x, frame_y;frame_x10,154
	Vec3 frame_x, frame_y;frame_y10,154
	double angle0, angle1;angle011,178
	double angle0, angle1;angle111,178
	Face* face;face12,202
Mat3x3 compute_sigma(const Face* face) {/*compute_sigma15,219
static Vec3 get_ms_span (Face* f, Node* center, int offset) {get_ms_span43,1312
double separation_strength(Node* node, SplitNode* split, bool always_compute) {separation_strength50,1534

sepstrength.hpp,412
#define SEPSTRENGTH_HPPSEPSTRENGTH_HPP28,1322
struct SplitNode {SplitNode32,1368
	Node* node;node33,1387
	Vec3 normal[2];normal34,1400
	double sep;sep35,1417
	Face* faces[2];faces36,1430
	SplitNode(Node* node) : node(node),sep(0) { faces[0] = faces[1] = NULL; normal[0] = normal[1]= Vec3(0); }SplitNode38,1448
    bool operator<(const SplitNode& o) const { return sep < o.sep; }operator <39,1555

simulation.cpp,2280
bool single_step = false;single_step48,1758
static const bool verbose = false;verbose50,1785
static const int proximity = Simulation::Proximity,proximity51,1820
                 physics = Simulation::Physics,physics52,1872
                 strainlimiting = Simulation::StrainLimiting,strainlimiting53,1920
                 collision = Simulation::Collision,collision54,1982
                 remeshing = Simulation::Remeshing,remeshing55,2034
                 separation = Simulation::Separation,separation56,2086
                 popfilter = Simulation::PopFilter,popfilter57,2140
                 plasticity = Simulation::Plasticity,plasticity58,2192
                 fracture = Simulation::Fracture;fracture59,2246
static void consistency(const char* text) {consistency71,2722
void prepare (Simulation &sim) {prepare82,2945
void relax_initial_state (Simulation &sim) {relax_initial_state104,3853
void validate_handles (const Simulation &sim) {validate_handles129,4625
void advance_frame (Simulation &sim) {advance_frame148,5333
void advance_step (Simulation &sim) {	advance_step153,5448
vector<Constraint*> get_constraints (Simulation &sim, bool include_proximity) {get_constraints190,6605
void delete_constraints (const vector<Constraint*> &cons) {delete_constraints204,7193
void physics_step (Simulation &sim, const vector<Constraint*> &cons) {physics_step215,7458
void step_mesh (Mesh &mesh, double dt) {step_mesh253,9078
void plasticity_step (Simulation &sim) {plasticity_step258,9224
void strainlimiting_step (Simulation &sim, const vector<Constraint*> &cons) {strainlimiting_step271,9599
void equilibration_step (Simulation &sim) {equilibration_step281,10008
void strainzeroing_step (Simulation &sim) {strainzeroing_step305,10856
void collision_step (Simulation &sim) {collision_step322,11564
void remeshing_step (Simulation &sim, bool initializing) {remeshing_step334,12003
void update_velocities (vector<Mesh*> &meshes, vector<Vec3> &xold, double dt) {update_velocities380,13495
void update_obstacles (Simulation &sim, bool update_positions) {update_obstacles390,13829
void add_jitter (Simulation& sim) { add_jitter409,14555
vector<Vec3> node_positions (const vector<Mesh*> &meshes) {node_positions418,14880

simulation.hpp,2203
#define SIMULATION_HPPSIMULATION_HPP28,1321
struct Wind {Wind40,1539
    double density;density41,1553
    Vec3 velocity;velocity42,1573
    double drag;drag43,1592
struct Simulation {Simulation46,1613
    double time;time48,1650
    int frame, step;frame49,1667
    int frame, step;step49,1667
    std::vector<Cloth> cloths;cloths50,1688
    int frame_steps, save_every;frame_steps52,1736
    int frame_steps, save_every;save_every52,1736
    double frame_time, step_time;frame_time53,1769
    double frame_time, step_time;step_time53,1769
    double end_time, end_frame;end_time54,1803
    double end_time, end_frame;end_frame54,1803
    double passive_time;passive_time55,1835
    std::vector<Motion> motions;motions56,1860
    std::vector<Handle*> handles;handles57,1893
    std::vector<Obstacle> obstacles;obstacles58,1927
    std::vector<Morph> morphs;morphs59,1964
    Vec3 gravity;gravity60,1995
    Wind wind;wind61,2013
    double friction, obs_friction;friction62,2028
    double friction, obs_friction;obs_friction62,2028
    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,Proximity63,2063
    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,Physics63,2063
    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,StrainLimiting63,2063
    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,Collision63,2063
    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,Remeshing63,2063
    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,Separation63,2063
          PopFilter, Plasticity, Fracture, nModules};PopFilter64,2143
          PopFilter, Plasticity, Fracture, nModules};Plasticity64,2143
          PopFilter, Plasticity, Fracture, nModules};Fracture64,2143
          PopFilter, Plasticity, Fracture, nModules};nModules64,2143
    bool enabled[nModules];enabled65,2197
    Timer timers[nModules];timers66,2225
    std::vector<Mesh*> cloth_meshes, obstacle_meshes;cloth_meshes68,2275
    std::vector<Mesh*> cloth_meshes, obstacle_meshes;obstacle_meshes68,2275

sparse.hpp,1142
#define SPARSE_HPPSPARSE_HPP28,1317
inline size_t find_index (int i, const std::vector<int> &indices) {find_index35,1414
template <typename T> void insert_index (int i, int j,insert_index42,1616
template <typename T> struct SpVec {SpVec49,1901
    std::vector<int> indices;indices50,1938
    std::vector<T> entries;entries51,1968
    T operator[] (int i) const {operator []52,1996
    T &operator[] (int i) {// inserts entry as side-effectoperator []59,2199
std::ostream &operator<< (std::ostream &out, const SpVec<T> &v) {operator <<68,2472
template <typename T> struct SpMat {SpMat76,2711
    int m, n;m77,2748
    int m, n;n77,2748
    std::vector< SpVec<T> > rows;rows78,2762
    SpMat (): m(0), n(0), rows() {}SpMat79,2796
    explicit SpMat (int m, int n): m(m), n(n), rows(m) {}SpMat80,2832
    T operator() (int i, int j) const {operator ()81,2890
    T &operator() (int i, int j) {// inserts entry as side-effectoperator ()84,2963
std::ostream &operator<< (std::ostream &out, const SpMat<T> &A) {operator <<90,3088
inline void debug_save_spmat (const SpMat<double> &A) {debug_save_spmat105,3541

spline.cpp,532
static int find (const Spline<T> &s, double t) {find35,1500
T Spline<T>::pos (double t) const {pos46,1765
T Spline<T>::vel (double t) const {vel63,2305
vector<double> operator+ (const vector<double> &x, const vector<double> &y) {operator +75,2690
vector<double> operator- (const vector<double> &x, const vector<double> &y) {operator -80,2895
vector<double> operator* (const vector<double> &x, double a) {operator *85,3100
vector<double> operator/ (const vector<double> &x, double a) {return x*(1/a);}operator /90,3270

spline.hpp,403
#define SPLINE_HPPSPLINE_HPP28,1317
class Spline {Spline34,1400
    struct Point {double t; T x, v;};Point37,1477
    struct Point {double t; T x, v;};t37,1477
    struct Point {double t; T x, v;};x37,1477
    struct Point {double t; T x, v;};v37,1477
    std::vector<Point> points;points38,1515
template <typename T> void fill_in_velocity (Spline<T> &s, int i) {fill_in_velocity50,1997

strainlimiting.cpp,1653
vector<StrainLimit> get_strain_limits (const vector<Cloth> &cloths) {get_strain_limits37,1453
T* get(int n, const vector<Mesh*>& meshes) {get54,2132
struct SLOpt: public NLConOpt {SLOpt64,2366
    vector<Mesh*> meshes;meshes65,2398
    int nn, nf;nn66,2424
    int nn, nf;nf66,2424
    const vector<StrainLimit> &strain_limits;strain_limits67,2440
    const vector<Constraint*> &cons;cons68,2486
    vector<Vec3> xold;xold69,2523
    vector<double> conold;conold70,2546
    mutable vector<double> s;s71,2573
    mutable vector<Mat3x3> sg;sg72,2603
    double inv_m;inv_m73,2634
    SLOpt (vector<Mesh*> &meshes, const vector<StrainLimit> &strain_limits,SLOpt74,2652
void strain_limiting (vector<Mesh*> &meshes, const vector<StrainLimit> &strain_limits,strain_limiting107,3890
void SLOpt::initialize (double *x) const {initialize112,4106
void SLOpt::precompute (const double *x) const {precompute119,4277
double SLOpt::objective (const double *x) const {objective143,5196
void SLOpt::obj_grad (const double *x, double *grad) const {obj_grad154,5491
double SLOpt::constraint (const double *x, int j, int &sign) const {constraint167,5942
void SLOpt::con_grad (const double *x, int j, double factor,con_grad174,6161
double strain_con (const SLOpt &sl, const double *x, int j, int &sign) {strain_con191,6735
void strain_con_grad (const SLOpt &sl, const double *x, int j, double factor,strain_con_grad217,7545
void add_strain_row (const Mat3x3 &sg, const Face *face,add_strain_row232,8101
void SLOpt::finalize (const double *x) const {finalize241,8399
void debug (const vector<string> &args) {debug250,8563

strainlimiting.hpp,303
#define STRAINLIMITING_HPPSTRAINLIMITING_HPP28,1325
struct StrainLimit {StrainLimit33,1401
    StrainLimit() : min(1), max(1) {}StrainLimit34,1422
    StrainLimit(double min, double max) : min(min), max(max) {}StrainLimit35,1460
    double min, max;min36,1524
    double min, max;max36,1524

subset.cpp,589
vector<Node*> MeshSubset::get_all_nodes() {get_all_nodes33,1386
vector<Vert*> MeshSubset::get_verts() {get_verts41,1687
vector<Face*> MeshSubset::get_faces() {get_faces49,1920
vector<Edge*> MeshSubset::get_edges() {get_edges62,2262
void MeshSubset::recompute_support(map<Node*,int>& acc) {recompute_support71,2497
void MeshSubset::update_support() {update_support83,2877
void MeshSubset::grow(int rings) {grow91,3056
void MeshSubset::set_flag(int flag) {set_flag104,3370
void MeshSubset::clear_flag(int flag) {clear_flag109,3498
void MeshSubset::debug() {debug114,3629

subset.hpp,188
#define SUBSET_HPPSUBSET_HPP28,1317
class MeshSubset {MeshSubset34,1393
	std::vector<Node*> active_nodes;active_nodes36,1420
	std::vector<Node*> support_nodes;support_nodes37,1454

taucs.cpp,709
ostream &operator<< (ostream &out, taucs_ccs_matrix *A) {operator <<49,1948
taucs_ccs_matrix *sparse_to_taucs (const SpMat<double> &As) {sparse_to_taucs68,2530
template <int m> taucs_ccs_matrix *sparse_to_taucs (const SpMat< Mat<m,m> > &As) {sparse_to_taucs97,3406
vector<double> alglib_linear_solve(const SpMat<double>& A, const vector<double>& b) {alglib_linear_solve132,4582
vector<Vec<C> > alglib_linear_solve_vec(const SpMat<Mat<C,C> >& A, const vector<Vec<C> >& b) {alglib_linear_solve_vec161,5319
vector<double> taucs_linear_solve (const SpMat<double> &A, const vector<double> &b) {taucs_linear_solve191,6152
template <int m> vector< Vec<m> > taucs_linear_solvetaucs_linear_solve209,6791

taucs.hpp,36
#define TAUCS_HPPTAUCS_HPP28,1316

tensormax.cpp,1136
struct Disk {Disk31,1365
    Vec2 c;c32,1379
    double r;r33,1391
    Disk (): c(Vec2(0)), r(0) {}Disk34,1405
    Disk (const Vec2 &c, double r): c(c), r(r) {}Disk35,1438
ostream &operator<< (ostream &out, const Disk &disk) {out << "Circle[{" << disk.c[0] << "," << disk.c[1] << "}," << disk.r << "]"; return out;}operator <<37,1491
Mat2x2 tensor_max (const vector<Mat2x2> &Ms) {tensor_max42,1732
Disk welzls_algorithm (const vector<Disk> &disks) {welzls_algorithm62,2400
Disk minidisk (const vector<Disk> &P) {minidisk71,2719
Disk b_minidisk (const vector<Disk> &P, const vector<Disk> &R) {b_minidisk83,2985
Disk b_md (const vector<Disk> &R) {b_md97,3368
Disk apollonius (const Disk &disk1, const Disk &disk2, const Disk &disk3) {apollonius111,3762
#define DEFXYR(DEFXYR113,3933
#undef DEFXYRDEFXYR117,4109
bool enclosed (const Disk &disk0, const Disk &disk1) {enclosed147,5050
template <typename T> T head (const vector<T> &v) {head151,5170
template <typename T> vector<T> tail (const vector<T> &v) {tail155,5247
template <typename T> vector<T> cons (const T &x, const vector<T> &v) {cons162,5415

tensormax.hpp,44
#define TENSORMAX_HPPTENSORMAX_HPP28,1320

timer.cpp,121
Timer::Timer (): last(0), total(0) {Timer33,1422
void Timer::tick () {tick37,1474
void Timer::tock () {tock41,1540

timer.hpp,188
#define __TIMER_H__TIMER_H29,1339
struct Timer {Timer36,1469
    boost::posix_time::ptime then;then37,1484
    double last, total;last38,1519
    double last, total;total38,1519

transformation.cpp,2079
Transformation identity () {identity31,1351
Transformation inverse(const Transformation &tr) {inverse35,1412
Quaternion inverse(const Quaternion &q) {inverse48,1716
Quaternion Quaternion::from_axisangle(const Vec3 &axis, double angle) {from_axisangle56,1879
pair<Vec3, double> Quaternion::to_axisangle() const {to_axisangle68,2139
Transformation::Transformation(double factor) {Transformation79,2385
Transformation Transformation::operator-(const Transformation& other) const {operator -85,2545
Transformation Transformation::operator+(const Transformation& other) const {operator +93,2812
Transformation Transformation::operator*(const Transformation& other) const {operator *101,3079
Transformation Transformation::operator*(double s) const {operator *110,3404
Transformation Transformation::operator/(double s) const {operator /118,3613
Quaternion Quaternion::operator+(const Quaternion& other) const {operator +122,3702
Quaternion Quaternion::operator-(const Quaternion& other) const {operator -129,3861
Quaternion Quaternion::operator-() const {operator -136,4020
Quaternion Quaternion::operator*(const Quaternion& other) const {operator *143,4138
Quaternion Quaternion::operator*(double s) const {operator *151,4388
Quaternion Quaternion::operator/(double s) const {operator /158,4520
Vec3 Quaternion::rotate (const Vec3 &x) const {rotate162,4601
Vec3 Transformation::apply (const Vec3 &x) const {apply167,4730
Vec3 Transformation::apply_vec (const Vec3 &v) const {apply_vec171,4835
double norm2(const Quaternion &q) {norm2175,4924
Quaternion normalize (const Quaternion &q) {normalize179,4996
void clean_up_quaternions (Motion &motion) {clean_up_quaternions187,5150
Transformation get_trans (const Motion &motion, double t) {get_trans197,5467
DTransformation get_dtrans (const Motion &motion, double t) {get_dtrans203,5622
Vec3 apply_dtrans (const DTransformation &dtrans, const Vec3 &x0, Vec3 *vel) {apply_dtrans214,6005
Vec3 apply_dtrans_vec (const DTransformation &dtrans, const Vec3 &v0) {apply_dtrans_vec225,6389

transformation.hpp,812
#define TRANSFORMATION_HPPTRANSFORMATION_HPP28,1325
struct Quaternion {Quaternion35,1441
    double s;s36,1461
    Vec3 v;v37,1475
inline std::ostream &operator<< (std::ostream &out, const Quaternion &q) {out << "(" << q.s << ", " << q.v << ")"; return out;}operator <<52,2061
struct Transformation {Transformation54,2190
    Vec3 translation;translation55,2214
    double scale;scale56,2236
    Quaternion rotation;rotation57,2254
inline std::ostream &operator<< (std::ostream &out, const Transformation &t) {out << "(translation: " << t.translation << ", rotation: " << t.rotation << ", scale: " << t.scale << ")"; return out;}operator <<70,2770
typedef Spline<Transformation> Motion;Motion72,2969
typedef std::pair<Transformation,Transformation> DTransformation;DTransformation73,3008

trustregion.cpp,802
void trust_region_method (const NLOpt &problem, OptOptions opt, bool verbose) {trust_region_method51,2142
bool minimize_in_ball (const vector<double> &g, const SpMat<double> &H,minimize_in_ball93,3620
double line_circle_intersection (double n1, double n2, double d, double r) {line_circle_intersection115,4293
static void add (vector<double> &v, const vector<double> &x,add124,4590
static void add (vector<double> &v, double a, const vector<double> &x,add133,4841
static void scalar_mult (vector<double> &v, double a, const vector<double> &x) {scalar_mult142,5116
static double dot (const vector<double> &x, const vector<double> &y) {dot150,5319
static double dot (const vector<double> &x, const SpMat<double> &A,dot159,5543
static double norm (const vector<double> &x) {norm177,6064

util.cpp,2975
void Stats::add (double x) {add40,1527
void Stats::sort () const {sort46,1614
double Stats::min () const {sort(); return xs.front();}min52,1725
double Stats::max () const {sort(); return xs.back();}max53,1781
double Stats::mean () const {return sum/xs.size();}mean54,1836
double Stats::median () const {return quantile(0.5);}median55,1888
double Stats::quantile (double q) const {sort(); return xs[(int)(q*xs.size())];}quantile56,1942
ostream &operator<< (ostream &out, const Stats &stats) {operator <<58,2024
inline string stringf (const string &format, ...) {stringf69,2396
template <typename T> string name (const T *p) {name78,2610
ostream &operator<< (ostream &out, const Vert *vert) {operator <<84,2777
ostream &operator<< (ostream &out, const Node *node) {operator <<92,2924
ostream &operator<< (ostream &out, const Edge *edge) {operator <<100,3083
ostream &operator<< (ostream &out, const Face *face) {operator <<108,3286
const double infinity = numeric_limits<double>::infinity();infinity115,3495
int solve_quadratic (double a, double b, double c, double x[2]) {solve_quadratic117,3556
bool is_seam_or_boundary (const Vert *v) {is_seam_or_boundary135,4033
bool is_seam_or_boundary (const Node *n) {is_seam_or_boundary139,4120
bool is_seam_or_boundary (const Edge *e) {is_seam_or_boundary146,4304
bool is_seam_or_boundary (const Face *f) {is_seam_or_boundary152,4485
bool is_seam (const Edge* e) {is_seam158,4661
void build_node_lookup(map<const Node*,Vec3>& nodemap, const vector<Mesh*>& meshes) {build_node_lookup164,4831
void segfault() {segfault171,5080
void debug_save_meshes (const vector<Mesh*> &meshvec, const string &name,debug_save_meshes175,5118
void debug_save_mesh (const Mesh &mesh, const string &name, int n) {debug_save_mesh186,5462
void serializer(T& v, Serialize& s, const string& name) { serializer197,5786
void serializer_dvec(vector<T>& v, Serialize& s, const string& name) { serializer_dvec215,6224
void serializer_vec(Vec<n>& x, Serialize& s, const string& name) { serializer_vec222,6412
void serializer_mat(Mat<n,n>& x, Serialize& s, const string& name) { serializer_mat228,6555
template<> void serializer<Vec2>(Vec2& x, Serialize& s,const string& n) { return serializer_vec(x,s,n); }serializer236,6881
template<> void serializer<Vec3>(Vec3& x, Serialize &s,const string& n) { return serializer_vec(x,s,n); }serializer237,6987
template<> void serializer<Mat2x2>(Mat2x2& x, Serialize& s,const string& n) { return serializer_mat(x,s,n); }serializer238,7093
template<> void serializer<Mat3x3>(Mat3x3& x, Serialize& s,const string& n) { return serializer_mat(x,s,n); }serializer239,7203
template<> void serializer<vector<Vec3> >(vector<Vec3>& x, Serialize& s, const string& n) { return serializer_dvec(x,s,n); }serializer240,7313
template<> void serializer<vector<double> >(vector<double>& x, Serialize& s, const string& n) { return serializer_dvec(x,s,n); }serializer241,7438

util.hpp,3192
#define UTIL_HPPUTIL_HPP28,1315
#define EPSILON	EPSILON40,1512
#define NEXT(NEXT44,1620
#define PREV(PREV45,1660
typedef unsigned int uint;uint47,1701
struct Stats {Stats53,1783
    mutable std::vector<double> xs;xs54,1798
    double sum;sum55,1834
    mutable bool sorted;sorted56,1850
    Stats (): sum(0) {}Stats57,1875
template <typename T> T sqr (const T& x) { return x*x; }sqr80,2554
template <typename T> T clamp (const T &x, const T &a, const T &b) {clamp82,2612
template <typename T> T min (const T &a, const T &b, const T &c) {min85,2724
template <typename T> T min (const T &a, const T &b, const T &c, const T &d) {min87,2830
template <typename T> T max (const T &a, const T &b, const T &c) {max90,2961
template <typename T> T max (const T &a, const T &b, const T &c, const T &d) {max92,3067
template <typename T> T sgn (const T &x) {return x<0 ? -1 : 1;}sgn95,3198
inline bool is_finite(double x) { return x > -1e300 && x < 1e300; }is_finite97,3263
template <typename T> inline int find (const T *x, T* const *xs, int n=3) {find103,3435
template <typename T> inline int find (const T &x, const T *xs, int n=3) {find106,3582
template <typename T> inline int find (const T &x, const std::vector<T> &xs) {find109,3728
template <typename T> inline bool is_in (const T *x, T* const *xs, int n=3) {is_in112,3886
template <typename T> inline bool is_in (const T &x, const T *xs, int n=3) {is_in115,3999
template <typename T> inline bool is_in (const T &x, const std::vector<T> &xs) {is_in118,4111
template <typename T> inline void include (const T &x, std::vector<T> &xs) {include121,4224
template <typename T> inline void remove (int i, std::vector<T> &xs) {remove124,4343
template <typename T> inline void exclude (const T &x, std::vector<T> &xs) {exclude127,4454
template <typename T> inline void replace (const T &v0, const T &v1, T vs[3]) {replace130,4586
inline void replace (const T &x0, const T &x1, std::vector<T> &xs) {replace134,4741
inline bool subset (const std::vector<T> &xs, const std::vector<T> &ys) {subset138,4885
inline void append (std::vector<T> &xs, const std::vector<T> &ys) {append144,5078
#define VEC_CMP(VEC_CMP149,5222
#undef VEC_CMPVEC_CMP160,5639
Vec<n,T> vec_min (const Vec<n,T> &u, const Vec<n,T> &v) {vec_min163,5684
Vec<n,T> vec_max (const Vec<n,T> &u, const Vec<n,T> &v) {vec_max168,5860
std::ostream &operator<< (std::ostream &out, const std::vector<T> &v) {operator <<190,6569
#define ECHO(ECHO198,6774
#define REPORT(REPORT200,6820
#define REPORT_ARRAY(REPORT_ARRAY202,6884
struct Serialize {Serialize206,7017
	enum Mode { Load = 0, Save, Check };Mode207,7036
	enum Mode { Load = 0, Save, Check };Load207,7036
	enum Mode { Load = 0, Save, Check };Save207,7036
	enum Mode { Load = 0, Save, Check };Check207,7036
	gzFile fp;fp209,7076
	int version;version210,7088
	Mode mode;mode211,7102
	bool load() { return mode == Load; }load213,7115
	bool save() { return mode == Save; }save214,7153
	bool check() { return mode == Check; }	check215,7191
void serializer_array(std::vector<T>& v, Serialize& s, const std::string& name) { serializer_array222,7343

vectors.cpp,1396
#define LAPACKE_dgesvd LAPACKE_dgesvd38,1470
#define LAPACKE_dsyev LAPACKE_dsyev39,1501
#define lapack_int lapack_int42,1539
#define LAPACK_ROW_MAJOR LAPACK_ROW_MAJOR43,1562
#define LAPACK_COL_MAJOR LAPACK_COL_MAJOR44,1591
template <int n> Vec<n> eigen_values (const Mat<n,n> &A) {eigen_values54,2059
template <int n> Eig<n> eigen_decomposition (const Mat<n,n> &A) {eigen_decomposition66,2447
int dsyevc3(const Mat3x3& A, Vec3& w) {dsyevc382,3003
template<> Vec3 eigen_values<3>(const Mat3x3& A) {eigen_values118,4268
template<> Eig<3> eigen_decomposition<3>(const Mat3x3 &B) {eigen_decomposition130,4538
template<> Vec2 eigen_values<2>(const Mat2x2& A) {eigen_values320,10509
template<> Eig<2> eigen_decomposition<2>(const Mat2x2 &A) {eigen_decomposition331,10836
template <int m, int n> SVD<m,n> singular_value_decomposition (const Mat<m,n> &A) {singular_value_decomposition373,11835
template<> SVD<3,2> singular_value_decomposition<3,2> (const Mat<3,2> &A) {singular_value_decomposition391,12466
template <int n> Mat<n,n> get_positive (const Mat<n,n> &A) {get_positive437,13761
template<> Vec2 solve_symmetric(const Mat2x2& A, const Vec2& b) {solve_symmetric446,14072
template<> Vec3 solve_symmetric(const Mat3x3& A, const Vec3& b) {solve_symmetric456,14403
template <int m, int n> Vec<n> solve_llsq(const Mat<m,n> &A, const Vec<m>& b) {solve_llsq475,15218

vectors.hpp,14590
#define VECTORS_HPPVECTORS_HPP28,1318
#define __align(__align43,1735
inline void* malloc_align(size_t size, size_t alignment = 32) { return _aligned_malloc(size, alignment); }malloc_align44,1777
inline void aligned_free(void *ptr)    { _aligned_free(ptr); }aligned_free45,1884
#define __align(__align48,2021
inline void* malloc_align(size_t size, size_t alignment = 32) {malloc_align51,2110
inline void aligned_free(void *ptr)    { free(ptr); }aligned_free59,2288
inline void* operator new(size_t sz)      { return malloc_align(sz); }operator new63,2368
inline void* operator new[](size_t sz)    { return malloc_align(sz); }operator new[]64,2439
inline void  operator delete(void *ptr)   { aligned_free(ptr); }operator delete65,2510
inline void  operator delete[](void *ptr) { aligned_free(ptr); }operator delete[]66,2575
inline double sq (double x) {return x*x;}sq69,2648
template <> struct static_assertion_failure<true> {void operator() () {}};static_assertion_failure72,2745
template <> struct static_assertion_failure<true> {void operator() () {}};operator ()72,2745
#define static_assert(static_assert73,2820
#define tpl tpl75,2883
#define VecnT VecnT76,2924
template <int n, typename T=double> class Vec {Vec78,2948
  __align(32) T c[n%4? 4*(1+n/4): n];c81,3023
    Vec () {for (int i = 0; i < n; i++) c[i] = 0;}Vec86,3092
    explicit Vec (T x) {for (int i = 0; i < n; i++) c[i] = x;}Vec87,3143
    explicit Vec (T x, T y) {static_assert(n==2); c[0] = x; c[1] = y;}Vec88,3206
    explicit Vec (T x, T y, T z) {static_assert(n==3); c[0] = x; c[1] = y; c[2] = z;}Vec89,3277
    explicit Vec (T x, T y, T z, T w) {static_assert(n==4); c[0] = x; c[1] = y; c[2] = z; c[3] = w;}Vec90,3363
    explicit Vec (T v0, T v1, T v2, T v3, T v4, T v5) {static_assert(n==6); c[0] = v0; c[1] = v1; c[2] = v2; c[3] = v3; c[4] = v4; c[5] = v5; }Vec91,3464
    T &operator[] (int i) {return c[i];}operator []92,3608
    const T &operator[] (int i) const {return c[i];}operator []93,3649
tpl VecnT operator+ (const VecnT &u) {return u;}operator +95,3705
tpl VecnT operator+ (const VecnT &u, const VecnT &v) {VecnT w; for (int i = 0; i < n; i++) w[i] = u[i] + v[i]; return w;}operator +96,3754
tpl VecnT &operator+= (VecnT &u, const VecnT &v) {return u = u + v;}operator +=97,3876
tpl VecnT operator- (const VecnT &u) {VecnT v; for (int i = 0; i < n; i++) v[i] = -u[i]; return v;}operator -98,3945
tpl VecnT operator- (const VecnT &u, const VecnT &v) {return u + (-v);}operator -99,4045
tpl VecnT &operator-= (VecnT &u, const VecnT &v) {return u = u - v;}operator -=100,4117
tpl VecnT operator* (const T &a, const VecnT &u) {VecnT v; for (int i = 0; i < n; i++) v[i] = a*u[i]; return v;}operator *101,4186
tpl VecnT operator* (const VecnT &u, const T &a) {return a*u;}operator *102,4299
tpl VecnT &operator*= (VecnT &u, const T &a) {return u = u*a;}operator *=103,4362
tpl VecnT operator/ (const VecnT &u, const T &a) {return u*(1/a);}operator /104,4425
tpl VecnT &operator/= (VecnT &u, const T &a) {return u = u/a;}operator /=105,4492
tpl bool operator== (const VecnT &u, const VecnT &v) {for(int i=0; i<n; ++i) if(u[i] != v[i]) return false; return true;}operator ==106,4555
tpl bool operator!= (const VecnT &u, const VecnT &v) {return !(u==v);}operator !=107,4677
tpl T dot (const VecnT &u, const VecnT &v) {T d = 0; for (int i = 0; i < n; i++) d += u[i]*v[i]; return d;}dot108,4748
tpl T norm2 (const VecnT &u) {return dot(u,u);}norm2109,4856
tpl T norm (const VecnT &u) {return sqrt(norm2(u));}norm110,4904
tpl VecnT normalize (const VecnT &u) {T m = norm(u); return m==0 ? VecnT(0) : u/m;}normalize111,4957
tpl std::ostream &operator<< (std::ostream &out, const VecnT &u) {out << "("; for (int i = 0; i < n; i++) out << (i==0?"":", ") << u[i]; out << ")"; return out;}operator <<112,5041
template <typename T> Vec<3,T> cross (const Vec<3,T> &u, const Vec<3,T> &v) {Vec<3,T> w; w[0] = u[1]*v[2] - u[2]*v[1]; w[1] = u[2]*v[0] - u[0]*v[2]; w[2] = u[0]*v[1] - u[1]*v[0]; return w;}cross113,5203
template <typename T> T stp (const Vec<3,T> &u, const Vec<3,T> &v, const Vec<3,T> &w) {return dot(u,cross(v,w));}stp114,5393
template <typename T> bool right_handed (const Vec<3,T> &u, const Vec<3,T> &v, const Vec<3,T> &w) {return stp(u,v,w) >= 0;}right_handed115,5507
template <int m, int n, typename T> Vec<m,T> project (const VecnT &u) {Vec<m,T> v; for (int i = 0; i < m; i++) v[i] = (i<n) ? u[i] : 0; return v;}project116,5631
template <typename T> Vec<2,T> perp (const Vec<2,T> &u) {return Vec<2,T>(-u[1],u[0]);}perp117,5778
inline Vec<2> reduce_xy(const Vec<3>& v) { return Vec<2>(v[0],v[1]); }reduce_xy118,5865
inline Vec<3> expand_xy(const Vec<2>& v) { return Vec<3>(v[0],v[1],0); }expand_xy119,5936
tpl void serializer_vec(gzFile fp, VecnT& v, bool save) { for(int i=0; i<3; i++) serializer(fp, v[i], save); }serializer_vec120,6009
tpl inline bool is_bullshit(const VecnT& v) { for (int i=0; i<n; i++) { if (v[i] > 1e100 || v[i] < -1e100 || v[i] != v[i]) return true; } return false; }is_bullshit121,6120
template<> inline Vec<3,double> operator+<3,double>(const Vec<3,double> &u, const Vec<3,double> &v) { __m256d r = _mm256_add_pd((__m256d&)u, (__m256d&)v); return (Vec<3,double>&)r; }operator +<127,6344
template<> inline Vec<3,double> operator-<3,double>(const Vec<3,double> &u, const Vec<3,double> &v) { __m256d r = _mm256_sub_pd((__m256d&)u, (__m256d&)v); return (Vec<3,double>&)r; }operator -<128,6527
template<> inline Vec<3,double> operator*<3,double>(const double &a, const Vec<3,double> &v) { __m256d r = _mm256_mul_pd(_mm256_set1_pd(a), (__m256d&)v); return (Vec<3,double>&)r; }operator *<129,6710
template<> inline Vec<3,double> operator/<3,double>(const Vec<3,double> &u, const double &a) { __m256d r = _mm256_div_pd((__m256d&)u, _mm256_set1_pd(a)); return (Vec<3,double>&)r; }operator /<130,6892
template<> inline Vec<3,double>& operator+=<3,double>(Vec<3,double> &r, const Vec<3,double> &v) { (__m256d&)r = _mm256_add_pd((__m256d&)r, (__m256d&)v); return r; }operator +=<132,7075
template<> inline Vec<3,double>& operator-=<3,double>(Vec<3,double> &r, const Vec<3,double> &v) { (__m256d&)r = _mm256_sub_pd((__m256d&)r, (__m256d&)v); return r; }operator -=<133,7240
inline Vec<3,double>& operator*=(Vec<3,double> &r, const Vec<3,double> &v)      { (__m256d&)r = _mm256_mul_pd((__m256d&)r, (__m256d&)v); return r; }operator *=136,7490
inline Vec<3,double>& operator/=(Vec<3,double> &r, const Vec<3,double> &v)      { (__m256d&)r = _mm256_div_pd((__m256d&)r, (__m256d&)v); return r; }operator /=137,7639
inline Vec<3,double>  operator*(const Vec<3,double> &u, const Vec<3,double> &v) { __m256d r = _mm256_mul_pd((__m256d&)u, (__m256d&)v); return (Vec<3,double>&)r; }operator *138,7788
inline Vec<3,double>  operator/(const Vec<3,double> &u, const Vec<3,double> &v) { __m256d r = _mm256_div_pd((__m256d&)u, (__m256d&)v); return (Vec<3,double>&)r; }operator /139,7951
#undef tpltpl142,8122
#undef VecnTVecnT143,8133
typedef Vec<2> Vec2;Vec2145,8147
typedef Vec<3> Vec3;Vec3146,8168
#define tpl tpl148,8190
#define MatmnT MatmnT149,8238
#define MatnmT MatnmT150,8264
#define MatnnT MatnnT151,8290
#define VecmT VecmT152,8316
#define VecnT VecnT153,8339
template <int m, int n, typename T=double> class Mat {Mat158,8466
    VecmT c[n];c160,8530
    Mat () {for (int j = 0; j < n; j++) c[j] = VecmT(0);}Mat162,8554
    explicit Mat (T x) {for (int j = 0; j < n; j++) {c[j] = VecmT(0); if (j < m) c[j][j] = x;}}Mat163,8612
    explicit Mat (VecmT x, VecmT y) {static_assert(n==2); c[0] = x; c[1] = y;}Mat164,8708
    explicit Mat (VecmT x, VecmT y, VecmT z) {static_assert(n==3); c[0] = x; c[1] = y; c[2] = z;}Mat165,8787
    explicit Mat (VecmT x, VecmT y, VecmT z, VecmT w) {static_assert(n==4); c[0] = x; c[1] = y; c[2] = z; c[3] = w;}Mat166,8885
	static Mat rows (VecnT x, VecnT y) { Mat<2,n,T> M; for(int i = 0; i < n; i++) { M.col(i)[0] = x[i]; M.col(i)[1] = y[i]; } return M; }rows169,9161
    static Mat rows (VecnT x, VecnT y, VecnT z) { Mat<3,n,T> M; for(int i = 0; i < n; i++) { M.col(i)[0] = x[i]; M.col(i)[1] = y[i]; M.col(i)[2] = z[i];} return M; }rows170,9296
    static Mat rows (VecnT x, VecnT y, VecnT z, VecnT w) { Mat<4,n,T> M; for(int i = 0; i < n; i++) { M.col(i)[0] = x[i]; M.col(i)[1] = y[i]; M.col(i)[2] = z[i]; M.col(i)[3] = w[i];} return M; }rows171,9462
    VecnT row (int i) const {VecnT R; for(int col = 0; col < n; ++col) { R[col] = c[col][i]; } return R; }row172,9657
    void set_row(int i, const VecnT& v) { for(int col = 0; col < n; ++col) c[col][i] = v[col]; }set_row173,9764
    inline T &operator() (int i, int j) {return c[j][i];}operator ()175,9862
    inline const T &operator() (int i, int j) const {return c[j][i];}operator ()176,9920
    inline VecmT &col (int j) {return c[j];}col177,9990
    inline const VecmT &col (int j) const {return c[j];}col178,10035
    MatnmT t () const {return transpose(*this);}t179,10092
    MatmnT inv () const {return inverse(*this);}inv181,10247
tpl MatmnT operator+ (const MatmnT &A) {return A;}operator +183,10299
tpl MatmnT operator+ (const MatmnT &A, const MatmnT &B) {MatmnT C; for (int j = 0; j < n; j++) C.col(j) = A.col(j) + B.col(j); return C;}operator +184,10350
tpl MatmnT &operator+= (MatmnT &A, const MatmnT &B) {return A = A + B;}operator +=185,10488
tpl MatmnT operator- (const MatmnT &A) {MatmnT B; for (int j = 0; j < n; j++) B.col(j) = -A.col(j); return B;}operator -186,10560
tpl MatmnT operator- (const MatmnT &A, const MatmnT &B) {return A + (-B);}operator -187,10671
tpl MatmnT &operator-= (MatmnT &A, const MatmnT &B) {return A = A - B;}operator -=188,10746
tpl MatmnT operator* (const T &a, const MatmnT &A) {MatmnT B; for (int j = 0; j < n; j++) B.col(j) = a*A.col(j); return B;}operator *189,10818
tpl MatmnT operator* (const MatmnT &A, const T &a) {return a*A;}operator *190,10942
tpl MatmnT &operator*= (MatmnT &A, const T &a) {return A = A*a;}operator *=191,11007
tpl MatmnT operator/ (const MatmnT &A, const T &a) {return A*(1/a);}operator /192,11072
tpl MatmnT &operator/= (MatmnT &A, const T &a) {return A = A/a;}operator /=193,11141
tpl VecmT operator* (const MatmnT &A, const VecnT &u) {VecmT v = VecmT(0); for (int j = 0; j < n; j++) v += A.col(j)*u[j]; return v;}operator *194,11206
template <int m, int n, int o, typename T> Mat<m,o,T> operator* (const Mat<m,n,T> &A, const Mat<n,o,T> &B) {Mat<m,o,T> C; for (int k = 0; k < o; k++) C.col(k) = A*B.col(k); return C;}operator *195,11340
tpl MatmnT *operator*= (const MatmnT &A, const MatnnT &B) {return A = A*B;}operator *=196,11524
tpl MatnmT transpose (const MatmnT &A) {MatnmT B; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) B(j,i) = A(i,j); return B;}transpose197,11600
template <int n, typename T> VecnT diag (const MatnnT &A) {VecnT u; for (int j = 0; j < n; j++) u[j] = A(j,j); return u;}diag198,11734
template <int n, typename T> T trace (const MatnnT &A) {T t = 0; for (int j = 0; j < n; j++) t += A(j,j); return t;}trace199,11856
template <typename T> T det (const Mat<2,2,T> &A) {return A(0,0)*A(1,1) - A(0,1)*A(1,0);}det200,11973
template <typename T> T det (const Mat<3,3,T> &A) {return stp(A.col(0), A.col(1), A.col(2));}det201,12063
template <typename T> Mat<2,2,T> inverse (const Mat<2,2,T> &A) {return Mat<2,2,T>(Vec<2,T>(A(1,1), -A(1,0)), Vec<2,T>(-A(0,1), A(0,0)))/det(A);}inverse202,12157
template <typename T> T wedge (const Vec<2,T> &u, const Vec<2,T> &v) {return u[0]*v[1] - u[1]*v[0];}wedge203,12302
template <typename T> Mat<3,3,T> inverse (const Mat<3,3,T> &A) {return Mat<3,3,T>(cross(A.col(1),A.col(2)), cross(A.col(2),A.col(0)), cross(A.col(0),A.col(1))).t()/det(A);}inverse204,12403
template <int n, typename T> MatnnT diag (const VecnT &u) {MatnnT A = MatnnT(0); for (int j = 0; j < n; j++) A(j,j) = u[j]; return A;}diag205,12576
tpl MatmnT outer (const VecmT &u, const VecnT &v) {MatmnT A; for (int j = 0; j < n; j++) A.col(j) = u*v[j]; return A;}outer206,12711
tpl T inner (const MatmnT &a, const MatmnT& b) { T r=0; for (int j=0; j<n; j++) for (int i=0; i<m; i++) r+=a.col(j)[i]*b.col(j)[i]; return r;}inner207,12830
tpl std::ostream &operator<< (std::ostream &out, const MatmnT &A) {MatnmT At = transpose(A); out << "(" << std::endl; for (int i = 0; i < m; i++) out << "    " << At.col(i) << (i+1==m?"":",") << std::endl; out << ")"; return out;}operator <<208,12973
inline Mat<2,2> reduce_xy (const Mat<3,3>& M) { return Mat<2,2> (Vec2(M(0,0),M(0,1)),Vec2(M(1,0),M(1,1))); }reduce_xy209,13204
inline Mat<3,3> expand_xy (const Mat<2,2>& M) { return Mat<3,3> (Vec3(M(0,0),M(0,1),0),Vec3(M(1,0),M(1,1),0),Vec3(0,0,0)); }expand_xy210,13313
tpl MatmnT max (const MatmnT& a, const MatmnT& b) { MatmnT c; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) c(i,j) = std::max(a(i,j), b(i,j)); return c; }max211,13438
tpl T norm2_F (const MatmnT &A) {T a = 0; for (int j = 0; j < n; j++) a += norm2(A.col(j)); return a;}norm2_F214,13622
tpl T norm_F (const MatmnT &A) {return sqrt(norm2_F(A));}norm_F215,13725
template <int m1, int n1, int m2, int n2, typename T> Mat<m1,n1,T> project (const Mat<m2,n2,T> &A) {Mat<m1,n1,T> B; for (int j = 0; j < n1; j++) B.col(j) = (j<n2) ? project<m1>(A.col(j)) : Vec<m1,T>(0); return B;}project217,13784
#undef tpltpl219,13999
#undef MatmnTMatmnT220,14010
#undef MatnnTMatnnT221,14024
#undef VecmTVecmT222,14038
#undef VecnTVecnT223,14051
typedef Mat<2,2> Mat2x2;Mat2x2225,14065
typedef Mat<3,3> Mat3x3;Mat3x3226,14090
typedef Mat<3,2> Mat3x2;Mat3x2227,14115
typedef Mat<2,3> Mat2x3;Mat2x3228,14140
template <int n> struct Eig {Eig230,14166
    Mat<n,n> Q;Q231,14196
    Vec<n> l;l232,14212
template <int m, int n> struct SVD {SVD238,14354
    Mat<m,m> U;U239,14391
    Vec<n> s;s240,14407
    Mat<n,n> Vt;Vt241,14421
template <int m, int n, typename T> class MatTransposed : protected Mat<m,n,T> {MatTransposed257,15203
    const Mat<m,n,T>& t () const {return static_cast<const Mat<m, n, T>&>(*this);}t263,15651
template <int m, int n, typename T> Vec<n, T> operator* (const MatTransposed<m,n,T> &A, const Vec<m, T> &u) operator *266,15738
template <int m, int n, int o, typename T> Mat<m,o,T> operator* (const Mat<m,n,T> &A, const MatTransposed<o,n,T> &B) operator *273,15932
template <int m, int n, int o, typename T> Mat<m,o,T> operator* (const MatTransposed<n,m,T> &A, const Mat<n,o,T> &B) operator *286,16247
#undef static_assertstatic_assert313,16876

winport.hpp,568
#define WINPORT_HPPWINPORT_HPP28,1318
#define _USE_MATH_DEFINES _USE_MATH_DEFINES40,1852
#undef minmin44,1938
#undef maxmax45,1949
#define snprintf snprintf47,1979
template <class T> inline bool isfinite(const T& number) { return boost::math::isfinite(number); }isfinite50,2063
template <class T> inline bool   finite(const T& number) { return boost::math::isfinite(number); }finite51,2162
inline double sqrt(int n) { return sqrt(double(n)); }sqrt53,2262
template <class T> inline T log2(const T& number) { return log(number)/log(T(2)); }log255,2317
